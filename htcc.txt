-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The full scratch implementation of tiny C compiler (x86_64)
--   
--   The full scratch implementation of tiny C compiler (x86_64). This
--   compiler outputs x86_64 assembly code from "general" C code.
--   
--   It consists of:
--   
--   <ul>
--   <li>the lexical analyzer</li>
--   <li>the parser that performs parsing with recursive descent and
--   construction of abstract syntax trees (ASTs)</li>
--   <li>the method that outputs x86_64 assembly code from ASTs</li>
--   </ul>
--   
--   <b>This compiler is not practical purposes</b>, but focuses on
--   implementation experiments.
--   
--   For more information, please see the README on GitHub at
--   <a>https://github.com/falgon/htcc#readme</a>.
@package htcc
@version 0.0.0.1


-- | Types and classes of the x86_64 registers
module Htcc.Asm.Intrinsic.Register

-- | The register type class
class Show a => IsRegister a

-- | The byte width of the register.
byteWidth :: IsRegister a => a -> Natural

-- | The accumulator register.
data AccumulatorReg

-- | Full 64 bits of register
RAX :: AccumulatorReg

-- | Lower 32 bits of register
EAX :: AccumulatorReg

-- | Lower 16 bits of register
AX :: AccumulatorReg

-- | Lower 8 bits of register
AH :: AccumulatorReg

-- | Upper 8 bits of <a>AX</a> register
AL :: AccumulatorReg

-- | The Base register.
data BaseReg

-- | Full 64 bits of register
RBX :: BaseReg

-- | Lower 32 bits of register
EBX :: BaseReg

-- | Lower 16 bits of register
BX :: BaseReg

-- | Lower 8 bit register
BH :: BaseReg

-- | Upper 8 bit register of <a>BX</a> register
BL :: BaseReg

-- | The Counter register.
data CounterReg

-- | Full 64 bits of register
RCX :: CounterReg

-- | Lower 32 bits of register
ECX :: CounterReg

-- | Lower 16 bits of register
CX :: CounterReg

-- | Lower 8 bit register
CH :: CounterReg

-- | Upper 8 bit register of <a>CX</a> register
CL :: CounterReg

-- | The Data register.
data DataReg

-- | Full 64 bits of register
RDX :: DataReg

-- | Lower 32 bits of register
EDX :: DataReg

-- | Lower 16 bits of register
DX :: DataReg

-- | Lower 8 bit register
DH :: DataReg

-- | Upper 8 bit register of <a>DX</a> register
DL :: DataReg

-- | The Source Index register.
data SrcIndexReg

-- | Full 64 bits of register
RSI :: SrcIndexReg

-- | Lower 32 bits of register
ESI :: SrcIndexReg

-- | Lower 16 bits of register
SI :: SrcIndexReg

-- | Lower 8 bits of register
SIL :: SrcIndexReg

-- | The Destination Index register.
data DstIndexReg

-- | Full 64 bits of register
RDI :: DstIndexReg

-- | Lower 32 bits of register
EDI :: DstIndexReg

-- | Lower 16 bits of register
DI :: DstIndexReg

-- | Lower 8 bits of register
DIL :: DstIndexReg

-- | The Base Pointer register.
data BasePtrReg

-- | Full 64 bits of register
RBP :: BasePtrReg

-- | Lower 32 bits of register
EBP :: BasePtrReg

-- | Lower 16 bits of register
BP :: BasePtrReg

-- | Lower 8 bits of register
BPL :: BasePtrReg

-- | The Stack Pointer register.
data StackPtrReg

-- | Full 64 bits of register
RSP :: StackPtrReg

-- | Lower 32 bits of register
ESP :: StackPtrReg

-- | Lower 16 bits of register
SP :: StackPtrReg

-- | Lower 8 bits of register
SPL :: StackPtrReg

-- | The extended general-purpose register (r8-r15).
data ExtendedReg

-- | Full 64 bits of register
Rn :: Int -> ExtendedReg

-- | Lower 32 bits of register
RnD :: Int -> ExtendedReg

-- | Lower 16 bits of register
RnW :: Int -> ExtendedReg

-- | Lower 8 bits of register
RnB :: Int -> ExtendedReg

-- | The registers.
data Register

-- | The accumulator
Accumulator :: AccumulatorReg -> Register

-- | The base
Base :: BaseReg -> Register

-- | The conuter
Counter :: CounterReg -> Register

-- | The data
Data :: DataReg -> Register

-- | The source index
SrcIndex :: SrcIndexReg -> Register

-- | The destination index
DstIndex :: DstIndexReg -> Register

-- | The base pointer index
BasePtr :: BasePtrReg -> Register

-- | The stack pointer index
StackPtr :: StackPtrReg -> Register

-- | The extended general-purpose
Extended :: ExtendedReg -> Register

-- | The rax register.
rax :: Register

-- | The eax register. Lower 32 bits of <a>rax</a>.
eax :: Register

-- | The ax register. Lower 16 bits of <a>rax</a>.
ax :: Register

-- | The ah register. Lower 8 bits of <a>rax</a>.
ah :: Register

-- | The al register. Upper 8 bits of <a>ax</a>.
al :: Register

-- | The rbx register.
rbx :: Register

-- | The ebx register. Lower 32 bits of <a>rbx</a>.
ebx :: Register

-- | The bx register. Lower 16 bits of <a>rbx</a>.
bx :: Register

-- | The bh register. Lower 8 bits of <a>rbx</a>.
bh :: Register

-- | The bl register. Upper 8 bits of <a>bx</a>.
bl :: Register

-- | The rcx register.
rcx :: Register

-- | The ecx register. Lower 32 bis of <a>rcx</a>.
ecx :: Register

-- | The cx register. Lower 16 bits of <a>rcx</a>.
cx :: Register

-- | The ch register. Lower 8 bits of <a>rcx</a>.
ch :: Register

-- | The cl register. Upper 8 bits of <a>cx</a>.
cl :: Register

-- | The rdx register.
rdx :: Register

-- | The edx register. Lower 32 bits of <a>rdx</a>.
edx :: Register

-- | The dx register. Lower 16 bits of <a>rdx</a>.
dx :: Register

-- | The dh register. Lower 8 bits of <a>rbx</a>.
dh :: Register

-- | The dl register. Upper 8 bits of <a>dx</a>.
dl :: Register

-- | The rsi register.
rsi :: Register

-- | The esi register. Lower 32 bits of <a>rsi</a>.
esi :: Register

-- | The si register. Lower 16 bits of <a>rsi</a>.
si :: Register

-- | The sil register. Lower 8 bits of <a>rsi</a>.
sil :: Register

-- | The rdi register.
rdi :: Register

-- | The edi register. Lower 32 bits of <a>rdi</a>.
edi :: Register

-- | The di register. Lower 16 bits of <a>rdi</a>.
di :: Register

-- | The dil register. Lower 8 bits of <a>rdi</a>.
dil :: Register

-- | The rbp register.
rbp :: Register

-- | The ebp register. Lower 32 bits of <a>rbp</a>.
ebp :: Register

-- | The bp register. Lower 16 bits of <a>rbp</a>.
bp :: Register

-- | The bpl register. Lower 8 bits of <a>rbp</a>.
bpl :: Register

-- | The rsp register.
rsp :: Register

-- | The esp register. Lower 32 bits of <a>rsp</a>.
esp :: Register

-- | The sp register. Lower 16 bits of <a>rsp</a>.
sp :: Register

-- | The spl register. Lower 8 bits of <a>rsp</a>.
spl :: Register

-- | The rn register (r8-r15).
rn :: Int -> Register

-- | The rnd register (r8d-r15d). Lower 32 bits of <a>rn</a>.
rnd :: Int -> Register

-- | The rnw register (r8w-r15w). Lower 16 bits of <a>rn</a>.
rnw :: Int -> Register

-- | The rnb register (r8b-r15b). Lower 8 bits of <a>rn</a>.
rnb :: Int -> Register

-- | <a>argRegs</a> is a list of each <tt>Register</tt> used in the
--   function call. In the list, the registers used for the first to sixth
--   arguments are arranged in ascending order.
argRegs :: [[Register]]

-- | <a>popRegs</a> is a list of registers used to <tt>pop</tt> arguments
--   from the stack in function calls. This is equivalent to the following,
--   but is defined explicitly for reducing time completity.
--   
--   <pre>
--   &gt;&gt;&gt; popRegs 3 == map maximum (reverse (take 3 argRegs))
--   </pre>
popRegs :: Int -> [Register]
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.Register
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.Register
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.Register
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.Register
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.ExtendedReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.ExtendedReg
instance GHC.Enum.Bounded Htcc.Asm.Intrinsic.Register.ExtendedReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.ExtendedReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.ExtendedReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.StackPtrReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.StackPtrReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.StackPtrReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.StackPtrReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.BasePtrReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.BasePtrReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.BasePtrReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.BasePtrReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.DstIndexReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.DstIndexReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.DstIndexReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.DstIndexReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.SrcIndexReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.SrcIndexReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.SrcIndexReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.SrcIndexReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.DataReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.DataReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.DataReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.DataReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.CounterReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.CounterReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.CounterReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.CounterReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.BaseReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.BaseReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.BaseReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.BaseReg
instance GHC.Show.Show Htcc.Asm.Intrinsic.Register.AccumulatorReg
instance Htcc.Asm.Intrinsic.Register.IsRegister Htcc.Asm.Intrinsic.Register.AccumulatorReg
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Register.AccumulatorReg
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Register.AccumulatorReg


-- | Types and classes of the x86_64 operands
module Htcc.Asm.Intrinsic.Operand

-- | <a>IsOperand</a> class has an operand type as instances.
class Show a => IsOperand a

-- | The operation of add.
oadd :: (IsOperand a, IsOperand b) => a -> b -> Operand

-- | The operation of sub.
osub :: (IsOperand a, IsOperand b) => a -> b -> Operand

-- | The operation of mul.
omul :: (IsOperand a, IsOperand b) => a -> b -> Operand

-- | The operand type.
newtype Operand

-- | The constructor of <a>Operand</a>.
Operand :: String -> Operand

-- | The type that specifies that register values are considered address
--   values. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; Ref rax
--   [rax]
--   
--   &gt;&gt;&gt; Ref rsp
--   [rsp]
--   
--   &gt;&gt;&gt; import qualified Data.Text as T
--   
--   &gt;&gt;&gt; T.putStr $ mov rax (Ref rsp) &lt;&gt; add rsp 8
--        mov rax, [rsp]
--        add rsp, 8
--   </pre>
newtype Ref a

-- | The constructor of <a>Ref</a>.
Ref :: a -> Ref a
[runRef] :: Ref a -> a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Real.Real a => GHC.Real.Real (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Num.Num a => GHC.Num.Num (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Arr.Ix a => GHC.Arr.Ix (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Real.Integral a => GHC.Real.Integral (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Generics.Generic1 Htcc.Asm.Intrinsic.Operand.Ref
instance GHC.Generics.Generic (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Float.Floating a => GHC.Float.Floating (Htcc.Asm.Intrinsic.Operand.Ref a)
instance Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Htcc.Asm.Intrinsic.Operand.Ref a)
instance Data.Bits.Bits a => Data.Bits.Bits (Htcc.Asm.Intrinsic.Operand.Ref a)
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Operand.Operand
instance GHC.Base.Monoid Htcc.Asm.Intrinsic.Operand.Operand
instance GHC.Base.Semigroup Htcc.Asm.Intrinsic.Operand.Operand
instance GHC.Generics.Generic Htcc.Asm.Intrinsic.Operand.Operand
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Operand.Operand
instance GHC.Base.Functor Htcc.Asm.Intrinsic.Operand.Ref
instance GHC.Base.Applicative Htcc.Asm.Intrinsic.Operand.Ref
instance GHC.Base.Monad Htcc.Asm.Intrinsic.Operand.Ref
instance Control.Monad.Fix.MonadFix Htcc.Asm.Intrinsic.Operand.Ref
instance Control.Monad.Zip.MonadZip Htcc.Asm.Intrinsic.Operand.Ref
instance Htcc.Asm.Intrinsic.Operand.IsOperand a => GHC.Show.Show (Htcc.Asm.Intrinsic.Operand.Ref a)
instance Htcc.Asm.Intrinsic.Operand.IsOperand Htcc.Asm.Intrinsic.Operand.Operand
instance Htcc.Asm.Intrinsic.Operand.IsOperand GHC.Types.Int
instance Htcc.Asm.Intrinsic.Operand.IsOperand GHC.Integer.Type.Integer
instance Htcc.Asm.Intrinsic.Operand.IsOperand Htcc.Asm.Intrinsic.Register.Register
instance GHC.Show.Show Htcc.Asm.Intrinsic.Operand.Operand


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic


-- | LexicalElements of C language
module Htcc.CRules.LexicalElements

-- | Valid one characters as C language
charOps :: String

-- | Valid two characters as C language
strOps2 :: [Text]

-- | Valid three characters as C language
strOps3 :: [Text]


-- | The puncuators of preprocessor
module Htcc.CRules.Preprocessor.Punctuators

-- | <a>bgMacro</a> is the character that starts the macro, so it is
--   <tt>#</tt>
bgMacro :: Char

-- | <a>Macros</a> is a macro token defined in C.
data Macros

-- | the <tt>include</tt>
MacInclude :: Macros

-- | all macros
macros :: [Macros]

-- | the length of the macro
length :: Macros -> Int
instance GHC.Generics.Generic Htcc.CRules.Preprocessor.Punctuators.Macros
instance GHC.Enum.Enum Htcc.CRules.Preprocessor.Punctuators.Macros
instance GHC.Classes.Eq Htcc.CRules.Preprocessor.Punctuators.Macros
instance Control.DeepSeq.NFData Htcc.CRules.Preprocessor.Punctuators.Macros
instance GHC.Show.Show Htcc.CRules.Preprocessor.Punctuators.Macros


-- | The rules of types of C language
module Htcc.CRules.Types.CType

-- | A data type representing the type of C language
class CType a

-- | <a>isFundamental</a> returns <a>True</a> only if the type is
--   fundamental type (See also: ยง 3.9.1), otherwise retunrs <a>False</a>.
isFundamental :: CType a => a -> Bool

-- | If the first argument is a type qualifier, <a>qualify</a> returns a
--   type that qualifies the type of the second argument with that
--   qualifier. Otherwise <a>Nothing</a> is returned.
qualify :: CType a => a -> a -> Maybe a

-- | <a>sizeof</a> returns the byte size of the type defined by C language.
sizeof :: CType a => a -> Natural

-- | <a>alignof</a> returns the alignment of the type defiend by C
--   language.
alignof :: CType a => a -> Natural

-- | <a>deref</a> returns <tt>Just x</tt> for the underlying type
--   <tt>x</tt> only if <tt>a</tt> is <a>CTPtr</a> or <a>CTArray</a>.
--   Otherwise returns <a>Nothing</a>.
deref :: CType a => a -> Maybe a

-- | <a>ctorPtr</a> returns a convolution function with &lt;math&gt;
--   specified pointers nested
ctorPtr :: CType a => Natural -> a -> a

-- | <a>dctorPtr</a> deconstructs the nested structure of <a>CTPtr</a> and
--   returns the convolution function of the original type and <a>CTPtr</a>
dctorPtr :: CType a => a -> (a, a -> a)

-- | <a>dctorArray</a> deconstructs the nested structure of <a>CTArray</a>
--   and returns the convolution function of the original type and
--   <a>CTArray</a>
dctorArray :: CType a => a -> (a, a -> a)

-- | <a>removeAllExtents</a> is the same as
--   <tt>std::remove_all_extents</tt> defined in C++11
--   <tt>&lt;type_traits&gt;</tt> (See also: <a>N3337</a>/ยง 20.9.7.4)
--   header. If type <tt>T</tt> is a multidimensional array of type
--   <tt>X</tt>, type <tt>X</tt> is returned. Otherwise, it returns type
--   <tt>T</tt>.
removeAllExtents :: CType a => a -> a

-- | <a>conversion</a> defines one type from two types according to the
--   implicit conversion defined in ยง6.3.1.8
conversion :: CType a => a -> a -> a

-- | <a>implicitInt</a> sets long or short type declarations for type
--   declarations with only modifiers such as long and short. Otherwise,
--   nothing to do.
implicitInt :: CType a => a -> a


-- | Utilities used to handle scopes
module Htcc.Parser.ConstructionData.Scope.Utils

-- | the message of an internal compiler error
internalCE :: Text


-- | Utilities of boolean
module Htcc.Utils.Bool

-- | For mappings &lt;math&gt; to an element &lt;math&gt; of a set
--   &lt;math&gt;, &lt;math&gt; where &lt;math&gt; is the boolean domain.
--   This function will stop evaluation when the result of &lt;math&gt; is
--   <a>True</a> (short circuit evaluation). This is equivalent to:
--   
--   <pre>
--   f1 x || f2 x || f3 x == lor [f1, f2, f3] x
--   </pre>
lor :: [a -> Bool] -> a -> Bool

-- | For mappings &lt;math&gt; to an element (xin X) of a set &lt;math&gt;,
--   &lt;math&gt; where &lt;math&gt; is the boolean domain. This is
--   equivalent to:
--   
--   <pre>
--   f1 x &amp;&amp; f2 x &amp;&amp; f3 x == land [f1, f2, f3] x
--   </pre>
land :: [a -> Bool] -> a -> Bool

-- | Sum of product form. For mappings &lt;math&gt; to an element
--   &lt;math&gt; of a set &lt;math&gt;, &lt;math&gt; where &lt;math&gt; is
--   the Boolean domain. This function will stop evaluation when the result
--   of &lt;math&gt; is <a>True</a> (short circuit evaluation).
sop :: [a -> Bool] -> [a] -> Bool

-- | The <a>Text</a> version of <a>sop</a>.
sopText :: [Char -> Bool] -> Text -> Bool


-- | Utilities of natural transformations
module Htcc.Utils.NaturalTransformations

-- | Natural transformation from <tt>Maybe</tt> functor to <tt>Either
--   e</tt> functor
maybeToRight :: e -> Maybe ~> Either e


-- | Utilities of print
module Htcc.Utils.Print

-- | Standard error output shortcut.
putStrErr :: Text -> IO ()

-- | Standard error output shortcut (with new line).
putStrLnErr :: Text -> IO ()

-- | Standard error output and exit shortcut.
err :: Text -> IO ()

-- | Execute <a>putDoc</a> by applying <a>linebreak</a> to <a>&lt;&gt;</a>
--   at the end of given <a>Doc</a>
putDocLn :: Doc -> IO ()

-- | The shortcut of <tt>hPutDoc stderr</tt>
putDocErr :: Doc -> IO ()

-- | Execute <a>putDocErr</a> by applying <a>linebreak</a> to
--   <a>&lt;&gt;</a> at the end of given <a>Doc</a>
putDocLnErr :: Doc -> IO ()

-- | The <a>Doc</a> used to output an error message (<a>String</a>), it is
--   shortcut of <tt>red . text</tt>
errTxtDoc :: String -> Doc

-- | The <a>Doc</a> used to output an error message (<a>Char</a>), it is
--   shortcut of <tt>red. char</tt>
errCharDoc :: Char -> Doc

-- | The <a>Doc</a> used to output an warning message (<a>String</a>), it
--   is shortcut of <tt>magenta . text</tt>
warnTxtDoc :: String -> Doc

-- | The <a>Doc</a> used to output an warning message (<a>Char</a>), it is
--   shortcut of <tt>magenta . char</tt>
warnCharDoc :: Char -> Doc

-- | Doc used to output a message (<a>String</a>) about the location, such
--   as the file name and its location, it is shortcut of <tt>bold .
--   text</tt>
locTxtDoc :: String -> Doc

-- | Doc used to output a message (<a>Char</a>) about the location, such as
--   the file name and its location, it is shortcut of <tt>bold . char</tt>
locCharDoc :: Char -> Doc


-- | Utilities of tuple
module Htcc.Utils.Tuple

-- | Swap a first element and second element
swap :: (a, b) -> (b, a)

-- | Update the first component of triple.
first3 :: (a -> d) -> (a, b, c) -> (d, b, c)

-- | Update the second component of triple.
second3 :: (b -> d) -> (a, b, c) -> (a, d, c)

-- | Update the third component of triple.
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)

-- | Drop first element of triple and returns pair
dropFst3 :: (a, b, c) -> (b, c)

-- | Drop second element of triple and returns pair
dropSnd3 :: (a, b, c) -> (a, c)

-- | Drop third element of triple and returns pair
dropThd3 :: (a, b, c) -> (a, b)

-- | Take first element of quadruple.
fst4 :: (a, b, c, d) -> a

-- | Take second element of quadruple.
snd4 :: (a, b, c, d) -> b

-- | Take third element of quadruple.
thd4 :: (a, b, c, d) -> c

-- | Take fourth element of quadruple.
fou4 :: (a, b, c, d) -> d

-- | Update first component of quadruple.
first4 :: (a -> e) -> (a, b, c, d) -> (e, b, c, d)

-- | Update second component of quadruple.
second4 :: (b -> e) -> (a, b, c, d) -> (a, e, c, d)

-- | Update third component of quadruple.
third4 :: (c -> e) -> (a, b, c, d) -> (a, b, e, d)

-- | Update fourth component of quadruple.
fourth4 :: (d -> e) -> (a, b, c, d) -> (a, b, c, e)

-- | Drop first element of quadruple.
dropFst4 :: (a, b, c, d) -> (b, c, d)

-- | Drop second element of quadruple.
dropSnd4 :: (a, b, c, d) -> (a, c, d)

-- | Drop third element of quadruple.
dropThd4 :: (a, b, c, d) -> (a, b, d)

-- | Drop fourth element of quadruple.
dropFourth4 :: (a, b, c, d) -> (a, b, c)

-- | Converts an uncurried function to a curried function.
curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e

-- | Converts a curried function to a function on a quadruple.
uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e


-- | Text utilities
module Htcc.Utils.Text

-- | Convert <a>Show</a> class instance to <a>Text</a>.
tshow :: Show a => a -> Text

-- | <a>Text</a> version of the <a>spanLen</a>.
spanLenT :: (Char -> Bool) -> Text -> (Int, Text, Text)

-- | <a>subTextIndex</a> searches text for a substring of text and returns
--   its starting position. If nothing is found, <a>Nothing</a> is
--   returned.
subTextIndex :: Text -> Text -> Maybe Int


-- | List utilities
module Htcc.Utils.List

-- | <a>takeWhileLen</a>, applied to a predicate <tt>f</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>f</tt> and the length of the
--   list taken. The time complexity of this function is equivalent to
--   <a>takeWhile</a>.
takeWhileLen :: (a -> Bool) -> [a] -> (Int, [a])

-- | <a>splitAtLen</a>, simmilar to <a>splitAt</a> but also returns the
--   length of the splited list.
splitAtLen :: Int -> [a] -> (Int, [a], [a])

-- | Almost the same as <a>span</a>, but returns the number of elements in
--   the list that satisfy <tt>f</tt> at the same time.
spanLen :: (a -> Bool) -> [a] -> (Int, [a], [a])

-- | <a>lastInit</a> returns <tt>Just (init xxs)</tt> when <tt>f (last x)
--   == True</tt> for then given list <tt>xxs</tt>. Otherwise, returns
--   <a>Nothing</a>
lastInit :: (a -> Bool) -> [a] -> Maybe [a]


-- | General-purpose utilities
module Htcc.Utils

-- | The monadic <a>both</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;- newIORef (42 :: Int)
--   
--   &gt;&gt;&gt; b &lt;- newIORef (53 :: Int)
--   
--   &gt;&gt;&gt; bothM readIORef (a, b) &gt;&gt;= print
--   (42,53)
--   </pre>
bothM :: Monad m => (a -> m b) -> (a, a) -> m (b, b)

-- | The monadic <a>***</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;- newIORef 1
--   
--   &gt;&gt;&gt; b &lt;- newIORef 2
--   
--   &gt;&gt;&gt; (writeIORef a *^* writeIORef b) (42, 53) &gt;&gt; bothM readIORef (a, b) &gt;&gt;= print
--   (42,53)
--   </pre>
(*^*) :: Monad m => (a -> m c) -> (b -> m d) -> (a, b) -> m (c, d)
infixr 3 *^*

-- | <a>maybe</a>` is <a>maybe</a> with changed argument order.
maybe' :: b -> Maybe a -> (a -> b) -> b

-- | <a>isStrictSpace</a> returns True only if the given string is not a
--   linefeed code and <a>isSpace</a> returns <a>True</a>, otherwise
--   returns <a>False</a>.
isStrictSpace :: Char -> Bool

-- | <a>toNatural</a> is a shortcut for <tt>fromIntegral :: Integral i
--   =&gt; i -&gt; Natural</tt>
toNatural :: Integral i => i -> Natural

-- | <a>toInteger</a> is a shortcut for <tt>fromIntegral :: Natural -&gt;
--   Integer</tt>
toInteger :: Natural -> Integer

-- | Convert the instance of <a>Integral</a> to Int. When it cause
--   overflow, express it as a list of <a>Int</a>s divided into multiple
--   values. <a>toInts</a> is useful for functions that have an <a>Int</a>
--   type as an argument. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; toInts (fromIntegral (maxBound :: Int) + 1 :: Integer)
--   [9223372036854775807,1]
--   
--   &gt;&gt;&gt; toInts (fromIntegral (maxBound :: Int) * 3 + 4 :: Integer)
--   [9223372036854775807,9223372036854775807,9223372036854775807,4]
--   </pre>
toInts :: Integral i => i -> [Int]


-- | Characters rules of C language
module Htcc.CRules.Char

-- | Return <a>True</a> if it is a valid character.
isValidChar :: Char -> Bool

-- | Class of type that can be treated as a set of characters.
class GenericStr a

-- | Returns <a>True</a> if the set of characters is a valid C language
--   characters.
isValid :: GenericStr a => a -> Bool
instance Htcc.CRules.Char.GenericStr GHC.Base.String
instance Htcc.CRules.Char.GenericStr Data.Text.Internal.Text


-- | The types of C language
module Htcc.CRules.Types.TypeKind

-- | The type and offset value of a data member.
data StructMember i

-- | <a>StructMember</a> constructor
StructMember :: TypeKind i -> Natural -> StructMember i

-- | The type of a data member
[smType] :: StructMember i -> TypeKind i

-- | The offset of a data member
[smOffset] :: StructMember i -> Natural

-- | The kinds of types in C language.
data TypeKind i

-- | The type <tt>int</tt> as C language
CTInt :: TypeKind i

-- | The type <tt>char</tt> as C language
CTChar :: TypeKind i

-- | The type <tt>signed</tt> as C language
CTSigned :: TypeKind i -> TypeKind i

-- | The type <tt>short</tt> as C language
CTShort :: TypeKind i -> TypeKind i

-- | The type <tt>long</tt> as C language
CTLong :: TypeKind i -> TypeKind i

-- | The type <tt>_Bool</tt> as C language
CTBool :: TypeKind i

-- | The type <tt>void</tt> as C language
CTVoid :: TypeKind i

-- | The pointer type of <a>TypeKind</a>
CTPtr :: TypeKind i -> TypeKind i

-- | The array type
CTArray :: Natural -> TypeKind i -> TypeKind i

-- | The enum, has its underlying type and a map
CTEnum :: TypeKind i -> Map Text i -> TypeKind i

-- | The struct, has its members and their names.
CTStruct :: Map Text (StructMember i) -> TypeKind i

-- | The incomplete type.
CTIncomplete :: Incomplete i -> TypeKind i

-- | Undefined type
CTUndef :: TypeKind i

-- | The type representing an incomplete type
data Incomplete i

-- | incomplete array, it has a base type.
IncompleteArray :: TypeKind i -> Incomplete i

-- | incomplete struct, it has a tag name.
IncompleteStruct :: Text -> Incomplete i

-- | Class to a type based on <a>TypeKind</a>.
class TypeKindBase a

-- | <a>isCTArray</a> returns <a>True</a> when the given argument is
--   <a>CTArray</a>. Otherwise, returns <a>False</a>
isCTArray :: TypeKindBase a => a i -> Bool

-- | <a>isArray</a> return <a>True</a> when the given argument is
--   <a>CTArray</a> or <a>IncompleteArray</a> Otherwise, returns
--   <a>False</a>
isArray :: TypeKindBase a => a i -> Bool

-- | <a>isCTStruct</a> returns <a>True</a> when the given argument is
--   <a>CTStruct</a>. Otherwise, returns <a>False</a>
isCTStruct :: TypeKindBase a => a i -> Bool

-- | <a>isCTUndef</a> returns <a>True</a> when the given argument is
--   <a>CTUndef</a>. Otherwise, returns <a>False</a>
isCTUndef :: TypeKindBase a => a i -> Bool

-- | <a>isCTIncomplete</a> returns <a>True</a> when the given argument is
--   <a>CTIncomplete</a>.
isCTIncomplete :: TypeKindBase a => a i -> Bool

-- | <a>makeCTArray</a> retunrs a multidimensional array based on the
--   arguments (list of each dimension). e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; makeCTArray [1, 2] CTInt
--   int[1][2]
--   
--   &gt;&gt;&gt; makeCTArray [1, 2] (CTArray 2 CTInt)
--   int[2][1][2]
--   </pre>
makeCTArray :: TypeKindBase a => [Natural] -> a i -> a i

-- | Only if both arguments is <a>CTArray</a>, <a>concatCTArray</a> returns
--   a new multidimensional array by conbining the types of
--   multidimensional arrays as follows.
--   
--   <pre>
--   &gt;&gt;&gt; makeCTArray [1, 2] CTInt `concatCTArray` makeCTArray [3, 4] CTInt
--   Just int[1][2][3][4]
--   
--   &gt;&gt;&gt; CTInt `concatCTArray` CTArray 2 CTInt
--   Nothing
--   </pre>
concatCTArray :: (TypeKindBase a, Ord i) => a i -> a i -> Maybe (a i)

-- | Convert to <a>TypeKind</a>.
toTypeKind :: TypeKindBase a => a i -> TypeKind i

-- | Application to <a>TypeKind</a>.
mapTypeKind :: TypeKindBase a => (TypeKind i -> TypeKind j) -> a i -> a j

-- | A class requesting a type that represents an incomplete type.
class IncompleteBase a

-- | When the given argument is incomplete array, <a>isIncompleteArray</a>
--   returns <a>True</a>, otherwise <a>False</a>.
isIncompleteArray :: IncompleteBase a => a i -> Bool

-- | When the given argument is incmoplete struct,
--   <a>isIncompleteStruct</a> returns <a>True</a>, otherwise <a>False</a>.
isIncompleteStruct :: IncompleteBase a => a i -> Bool

-- | Extract the tag name from <a>IncompleteStruct</a>. If not
--   <a>IncompleteStruct</a>, <a>Nothing</a> is retunred.
fromIncompleteStruct :: IncompleteBase a => a i -> Maybe Text

-- | Extract the type of array from <a>IncompleteArray</a>. If not
--   <a>IncompleteArray</a>, <a>Nothing</a> is retunred.
fromIncompleteArray :: IncompleteBase a => a i -> Maybe (TypeKind i)

-- | Returns True if the incomplete type is temporarily valid at the time
--   of declaration. Otherwise returns <a>False</a>.
isValidIncomplete :: (IncompleteBase a, Ord i) => a i -> Bool

-- | <a>lookupMember</a> search the specified member by its name from
--   <a>CTStruct</a>.
lookupMember :: Text -> TypeKind i -> Maybe (StructMember i)

-- | <a>alignas</a> align to <tt>n</tt>.
alignas :: (Bits a, Num a, Enum a) => a -> a -> a

-- | The type of designator
data Desg i

-- | index type
DesgIdx :: i -> Desg i

-- | struct member type
DesgMem :: StructMember i -> Desg i

-- | If the given argument is <a>CTArray</a>, it returns a list of
--   accessible indexes of the array. Othrewise returns empty list.
accessibleIndices :: Integral i => TypeKind i -> [[Desg i]]
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.CRules.Types.TypeKind.Desg i)
instance GHC.Generics.Generic (Htcc.CRules.Types.TypeKind.StructMember i)
instance (GHC.Show.Show i, GHC.Read.Read i, GHC.Classes.Ord i) => GHC.Read.Read (Htcc.CRules.Types.TypeKind.StructMember i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.CRules.Types.TypeKind.StructMember i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.CRules.Types.TypeKind.StructMember i)
instance GHC.Generics.Generic (Htcc.CRules.Types.TypeKind.Incomplete i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.CRules.Types.TypeKind.Incomplete i)
instance GHC.Generics.Generic (Htcc.CRules.Types.TypeKind.TypeKind i)
instance (GHC.Classes.Eq i, GHC.Classes.Ord i, GHC.Real.Integral i) => GHC.Classes.Ord (Htcc.CRules.Types.TypeKind.Desg i)
instance (GHC.Enum.Enum i, GHC.Real.Integral i) => GHC.Enum.Enum (Htcc.CRules.Types.TypeKind.Desg i)
instance Htcc.CRules.Types.TypeKind.TypeKindBase Htcc.CRules.Types.TypeKind.TypeKind
instance Htcc.CRules.Types.TypeKind.IncompleteBase Htcc.CRules.Types.TypeKind.Incomplete
instance Htcc.CRules.Types.TypeKind.IncompleteBase Htcc.CRules.Types.TypeKind.TypeKind
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.CRules.Types.TypeKind.StructMember i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.CRules.Types.TypeKind.Incomplete i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.CRules.Types.TypeKind.Incomplete i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.CRules.Types.TypeKind.TypeKind i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.CRules.Types.TypeKind.TypeKind i)
instance (GHC.Show.Show i, GHC.Read.Read i, GHC.Classes.Ord i) => GHC.Read.Read (Htcc.CRules.Types.TypeKind.TypeKind i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.CRules.Types.TypeKind.TypeKind i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.CRules.Types.TypeKind.TypeKind i)
instance GHC.Classes.Ord i => Htcc.CRules.Types.CType.CType (Htcc.CRules.Types.TypeKind.TypeKind i)


-- | The storage-class of C language
module Htcc.CRules.Types.StorageClass

-- | The data type representing <a>StorageClass</a>
data StorageClass i

-- | The <tt>auto</tt> keyword
SCAuto :: TypeKind i -> StorageClass i

-- | The <tt>static</tt> keyword
SCStatic :: TypeKind i -> StorageClass i

-- | The <tt>register</tt> keyword
SCRegister :: TypeKind i -> StorageClass i

-- | <a>SCUndef</a> is used when storage-class specifier is not defined
SCUndef :: TypeKind i -> StorageClass i

-- | Class to a type based on <a>StorageClass</a>.
class StorageClassBase a

-- | When the given argument is <a>SCStatic</a>, <a>isSCStatic</a> returns
--   <a>True</a>, otherwise <a>False</a>.
isSCStatic :: StorageClassBase a => a i -> Bool
instance GHC.Generics.Generic (Htcc.CRules.Types.StorageClass.StorageClass i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.CRules.Types.StorageClass.StorageClass i)
instance Htcc.CRules.Types.StorageClass.StorageClassBase Htcc.CRules.Types.StorageClass.StorageClass
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.CRules.Types.StorageClass.StorageClass i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.CRules.Types.StorageClass.StorageClass i)
instance GHC.Classes.Ord i => Htcc.CRules.Types.CType.CType (Htcc.CRules.Types.StorageClass.StorageClass i)
instance Htcc.CRules.Types.TypeKind.TypeKindBase Htcc.CRules.Types.StorageClass.StorageClass
instance Htcc.CRules.Types.TypeKind.IncompleteBase Htcc.CRules.Types.StorageClass.StorageClass
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.CRules.Types.StorageClass.StorageClass i)


-- | The rules of types of C language
module Htcc.CRules.Types


-- | The AST data type and its utilities
module Htcc.Parser.AST.Core

-- | Specially <tt>for</tt> syntax tree type
data ATKindFor a

-- | The <tt>for</tt> keyword
ATForkw :: ATKindFor a

-- | The initial section of <tt>for</tt> statement
ATForInit :: ATree a -> ATKindFor a

-- | The conditional section of <tt>for</tt> statement
ATForCond :: ATree a -> ATKindFor a

-- | The incremental section of <tt>for</tt> statement
ATForIncr :: ATree a -> ATKindFor a

-- | The statement section of <tt>for</tt> statement
ATForStmt :: ATree a -> ATKindFor a

-- | The syntax tree type. Let &lt;math&gt;, Let &lt;math&gt; and
--   &lt;math&gt; be pointers to variables &lt;math&gt; and &lt;math&gt;,
--   respectively (<tt>p=&amp;a,q=&amp;b</tt>).
data ATKind a

-- | &lt;math&gt;: <tt>x + y</tt>
ATAdd :: ATKind a

-- | add operation for pointer &lt;math&gt;: <tt>p + x, x + p</tt>
ATAddPtr :: ATKind a

-- | &lt;math&gt;: <tt>x - y</tt>
ATSub :: ATKind a

-- | sub operation for pointer &lt;math&gt;: <tt>p - x</tt>
ATSubPtr :: ATKind a

-- | The distance of pointers &lt;math&gt;: <tt>p - q</tt>
ATPtrDis :: ATKind a

-- | &lt;math&gt;: <tt>x * y</tt>
ATMul :: ATKind a

-- | &lt;math&gt;: <tt>x / y</tt>
ATDiv :: ATKind a

-- | &lt;math&gt;: <tt>x % y</tt>
ATMod :: ATKind a

-- | addition assignment: <tt>a += b</tt>
ATAddAssign :: ATKind a

-- | subtraction assignment: <tt>a -= b</tt>
ATSubAssign :: ATKind a

-- | multiplication assignment: <tt>a *= b</tt>
ATMulAssign :: ATKind a

-- | division assignment: <tt>a /= b</tt>
ATDivAssign :: ATKind a

-- | addition assignment for pointer: <tt>p += q</tt>
ATAddPtrAssign :: ATKind a

-- | subtraction assignment for pointer: <tt>p -= q</tt>
ATSubPtrAssign :: ATKind a

-- | logical and: <tt>x &amp;&amp; y</tt>
ATLAnd :: ATKind a

-- | logical or: <tt>x || y</tt>
ATLOr :: ATKind a

-- | bitwise and: <tt>x &amp; y</tt>
ATAnd :: ATKind a

-- | bitwise and assignment: <tt>a &amp;= b</tt>
ATAndAssign :: ATKind a

-- | bitwise or: <tt>x | y</tt>
ATOr :: ATKind a

-- | bitwise or assignment: <tt>a |= b</tt>
ATOrAssign :: ATKind a

-- | bitwise xor: <tt>x ^ y</tt>
ATXor :: ATKind a

-- | bitwise xor assignment: <tt>a ^= b</tt>
ATXorAssign :: ATKind a

-- | bitwise not: <tt>~x</tt>
ATBitNot :: ATKind a

-- | left shift: <tt>x &lt;&lt; y</tt>
ATShl :: ATKind a

-- | left shift assignment: <tt>a &lt;&lt;= b</tt>
ATShlAssign :: ATKind a

-- | right shift: <tt>x &gt;&gt; y</tt>
ATShr :: ATKind a

-- | right shift assignment: <tt>a &gt;&gt;= b</tt>
ATShrAssign :: ATKind a

-- | &lt;math&gt;: <tt>x &lt; y</tt>
ATLT :: ATKind a

-- | &lt;math&gt;: <tt>x &lt;= y</tt>
ATLEQ :: ATKind a

-- | &lt;math&gt;: <tt>x &gt; y</tt>
ATGT :: ATKind a

-- | &lt;math&gt;: <tt>x &gt;= y</tt>
ATGEQ :: ATKind a

-- | &lt;math&gt;: <tt>x == y</tt>
ATEQ :: ATKind a

-- | &lt;math&gt;: <tt>x != y</tt>
ATNEQ :: ATKind a

-- | not operator <tt>!</tt>: <tt>!x</tt>
ATNot :: ATKind a

-- | addressing operator <tt>&amp;</tt>: <tt>&amp;x</tt>
ATAddr :: ATKind a

-- | dereferencing operator <tt>*</tt>: <tt>*p</tt>
ATDeref :: ATKind a

-- | assign operator: <tt>x=y</tt>
ATAssign :: ATKind a

-- | pre-increment operator: <tt>++a</tt>
ATPreInc :: ATKind a

-- | pre-decrement operator: <tt>--a</tt>
ATPreDec :: ATKind a

-- | post-increment operator: <tt>a++</tt>
ATPostInc :: ATKind a

-- | post-decrement operator: <tt>a--</tt>
ATPostDec :: ATKind a

-- | The number
ATNum :: a -> ATKind a

-- | conditional operator: <tt>a ? x : y;</tt>. It has three AST (cond,
--   then and else)
ATConditional :: ATree a -> ATree a -> ATree a -> ATKind a

-- | comma operator: <tt>x,b</tt>
ATComma :: ATKind a

-- | the cast operation: <tt>(type) x</tt>
ATCast :: ATKind a

-- | accessing the member of the <tt>struct</tt>
ATMemberAcc :: StructMember a -> ATKind a

-- | the <tt>return</tt> keyword
ATReturn :: ATKind a

-- | the <tt>if</tt> keyword
ATIf :: ATKind a

-- | the <tt>else</tt> keyword
ATElse :: ATKind a

-- | the <tt>switch</tt> keyword, it has the conditional expression and
--   compound statement by <tt>case</tt>s or <tt>default</tt>s
ATSwitch :: ATree a -> [ATree a] -> ATKind a

-- | the <tt>case</tt> keyword, it has the value of label number and a
--   constant value
ATCase :: a -> a -> ATKind a

-- | the <tt>default</tt> keyword
ATDefault :: a -> ATKind a

-- | the <tt>while</tt> keyword
ATWhile :: ATKind a

-- | the <tt>for</tt> keyword
ATFor :: [ATKindFor a] -> ATKind a

-- | the <tt>break</tt> keyword
ATBreak :: ATKind a

-- | the <tt>continue</tt> keyword
ATContinue :: ATKind a

-- | the <tt>goto</tt> keyword, it has name of the target label
ATGoto :: Text -> ATKind a

-- | the label, it has name of label.
ATLabel :: Text -> ATKind a

-- | the compound statement
ATBlock :: [ATree a] -> ATKind a

-- | the local variable. It has a type information (as <a>StorageClass</a>)
--   and an offset value
ATLVar :: StorageClass a -> a -> ATKind a

-- | the global variable. It has a type information (as
--   <a>StorageClass</a>) and an name
ATGVar :: StorageClass a -> Text -> ATKind a

-- | the function definition
ATDefFunc :: Text -> Maybe [ATree a] -> ATKind a

-- | the function call. It has a offset value and arguments (<a>Maybe</a>)
ATCallFunc :: Text -> Maybe [ATree a] -> ATKind a

-- | the expression of a statement
ATExprStmt :: ATKind a

-- | the statement of a expression (GNU extension)
ATStmtExpr :: [ATree a] -> ATKind a

-- | indicates nothing to do
ATNull :: ATree a -> ATKind a

-- | The data structure of abstract syntax tree
data ATree a

-- | The empty node
ATEmpty :: ATree a

-- | <a>ATKind</a> representing the kind of node and the two branches
--   <a>ATree</a> it has
ATNode :: ATKind a -> StorageClass a -> ATree a -> ATree a -> ATree a

-- | The kind of abstract tree
[atkind] :: ATree a -> ATKind a

-- | The data type
[atype] :: ATree a -> StorageClass a

-- | The left hand side abstract tree
[atL] :: ATree a -> ATree a

-- | The right hand side abstract tree
[atR] :: ATree a -> ATree a

-- | A class whose type can be converted to ATree
class Treealizable a

-- | Convert to <a>ATree</a>
treealize :: Treealizable a => a i -> ATree i

-- | <a>atBinary</a> is equivalent to <a>ATNode</a>
atBinary :: ATKind i -> StorageClass i -> ATree i -> ATree i -> ATree i

-- | <a>atUnary</a> is a shortcut for unary node
atUnary :: ATKind i -> StorageClass i -> ATree i -> ATree i

-- | <a>atNoLeaf</a> is equivalent to <tt>ATNode k t ATEmpty ATEmpty</tt>
atNoLeaf :: ATKind i -> StorageClass i -> ATree i

-- | <a>atLVar</a> is a shortcut for local variable node
atLVar :: StorageClass i -> i -> ATree i

-- | <a>atGVar</a> is a shortcut for global variable node
atGVar :: StorageClass i -> Text -> ATree i

-- | <a>atAssign</a> is a shortcut for constructing a assign node
atAssign :: ATree i -> ATree i -> ATree i

-- | <a>atNumLit</a> is a shortcut for constructing a numeric literal node
atNumLit :: i -> ATree i

-- | <a>atMemberAcc</a> is a shortcut for constructing a <a>ATMemberAcc</a>
--   node
atMemberAcc :: StructMember i -> ATree i -> ATree i

-- | <a>atExprStmt</a> is a shortcut for constructing a expression
--   statement node
atExprStmt :: ATree i -> ATree i

-- | <a>atBlock</a> is a shortcut for constructing a block node
atBlock :: [ATree i] -> ATree i

-- | <a>atNull</a> is a shortcut for constructing a null node
atNull :: ATree i -> ATree i

-- | <a>atDefFunc</a> is a shortcut for constructing a function node
atDefFunc :: Text -> Maybe [ATree i] -> StorageClass i -> ATree i -> ATree i

-- | <a>atReturn</a> is a shortcut for constructing a <tt>return</tt> node
atReturn :: StorageClass i -> ATree i -> ATree i

-- | <a>atIf</a> is a shortcut for constructing a <tt>if</tt> node
atIf :: ATree i -> ATree i -> ATree i

-- | <a>atElse</a> is a shortcut for constructing a <tt>else</tt> node
atElse :: ATree i -> ATree i -> ATree i

-- | <a>atWhile</a> is a shortcut for constructing a <tt>while</tt> node
atWhile :: ATree i -> ATree i -> ATree i

-- | <a>atFor</a> is a shortcut for constructing a <tt>for</tt> node
atFor :: [ATKindFor i] -> ATree i

-- | <a>atBreak</a> is a shortcut for constructing a <tt>break</tt> node
atBreak :: ATree i

-- | <a>atContinue</a> is a shortcut for constructing a <tt>continue</tt>
--   node
atContinue :: ATree i

-- | <a>atSwitch</a> is a shortcut for constructing a <tt>switch</tt> node
atSwitch :: ATree i -> [ATree i] -> StorageClass i -> ATree i

-- | <a>atCase</a> is a shortcut for constructing a <tt>case</tt> node
atCase :: i -> i -> ATree i -> ATree i

-- | <a>atDefault</a> is a shortcut for constructing a <tt>default</tt>
--   node
atDefault :: i -> ATree i -> ATree i

-- | <a>atGoto</a> is a shortcut for constructing a <tt>goto</tt> node
atGoto :: Text -> ATree i

-- | <a>atLabel</a> is a shortcut for constructing a <tt>label</tt> node
atLabel :: Text -> ATree i

-- | <a>atComma</a> is a shortcut for constructing a <tt>,</tt> node
atComma :: StorageClass i -> ATree i -> ATree i -> ATree i

-- | <a>atConditional</a> is a shortcut for constructing a <tt>?:</tt> node
atConditional :: StorageClass i -> ATree i -> ATree i -> ATree i -> ATree i

-- | <a>atCast</a> is a shortcut for constructing a cast node
atCast :: StorageClass i -> ATree i -> ATree i

-- | An utility of <a>ATForInit</a>. When an argument is <a>ATForInit</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForInit :: ATKindFor a -> Bool

-- | An utility of <a>ATForCond</a>. When an argument is <a>ATForCond</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForCond :: ATKindFor a -> Bool

-- | An utility <a>ATForStmt</a>. When an argument is <a>ATForStmt</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForStmt :: ATKindFor a -> Bool

-- | An utility <a>ATForIncr</a>. When an argument is <a>ATForIncr</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForIncr :: ATKindFor a -> Bool

-- | take ATree data from <a>ATKindFor</a>.
fromATKindFor :: ATKindFor a -> ATree a

-- | Returns True if the given <a>ATKind</a> is an assignment operator
--   other than simple assignment. Otherwise, returns <a>False</a>.
isComplexAssign :: ATKind a -> Bool

-- | <a>isEmptyExprStmt</a> returns <a>True</a> only if both sides of
--   <a>ATExprStmt</a> are <a>ATEmpty</a>. Otherwise, returns <a>False</a>.
isEmptyExprStmt :: ATree a -> Bool

-- | <a>isEmptyReturn</a> returns <a>True</a> only if the <a>ATKind</a> of
--   the given argument is <a>ATReturn</a> and the left side hand node of
--   the given argument is <a>ATEmpty</a>. Otherwise, returns <a>False</a>.
isEmptyReturn :: ATree a -> Bool

-- | <a>isNonEmptyReturn</a> returns <a>True</a> only if the <a>ATKind</a>
--   of the given argument is <a>ATReturn</a> and the left side hand node
--   of the given argument is not <a>ATEmpty</a>. Otherwise, returns
--   <a>False</a>.
isNonEmptyReturn :: ATree a -> Bool

-- | mapping for <a>ATKind</a>
mapATKind :: (ATKind i -> ATKind i) -> ATree i -> ATree i

-- | applying for <a>StorageClass</a> of <a>ATLVar</a> or <a>ATGVar</a>
modifyTypeATKind :: (StorageClass i -> StorageClass i) -> ATKind i -> ATKind i
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.AST.Core.ATKindFor a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.AST.Core.ATKind a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.AST.Core.ATree a)
instance Htcc.CRules.Types.TypeKind.IncompleteBase Htcc.Parser.AST.Core.ATKind


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.AST.DeduceKind

-- | Constructs a numeric addition or pointer addition node according to
--   the C language implicit conversion rules
addKind :: (Eq i, Ord i, Show i) => ATree i -> ATree i -> Maybe (ATree i)

-- | Constructs a number subtraction or pointer subtraction node according
--   to the C language implicit conversion rules
subKind :: (Eq i, Ord i) => ATree i -> ATree i -> Maybe (ATree i)


-- | The modules of C Rules
module Htcc.CRules


-- | Types used in lexical analysis and their utility functions
module Htcc.Tokenizer.Token

-- | <a>TokenLCNums</a> is data structure for storing the line number and
--   character number of each token
data TokenLCNums i

-- | The constructor of <a>TokenLCNums</a>
TokenLCNums :: !i -> !i -> TokenLCNums i

-- | line number
[tkLn] :: TokenLCNums i -> !i

-- | character number
[tkCn] :: TokenLCNums i -> !i

-- | <a>Token</a> and its <a>TokenLCNums</a>.
type TokenLC i = (TokenLCNums i, Token i)

-- | Token type
data Token i

-- | The reserved token
TKReserved :: Text -> Token i

-- | The number data
TKNum :: !i -> Token i

-- | The identifier
TKIdent :: Text -> Token i

-- | The <tt>return</tt> keyword
TKReturn :: Token i

-- | The <tt>if</tt> keyword
TKIf :: Token i

-- | The <tt>switch</tt> keyword
TKSwitch :: Token i

-- | The <tt>case</tt> keyword
TKCase :: Token i

-- | The <tt>default</tt> keyword
TKDefault :: Token i

-- | The <tt>else</tt> keyword
TKElse :: Token i

-- | The <tt>while</tt> keyword
TKWhile :: Token i

-- | The <tt>for</tt> keyword
TKFor :: Token i

-- | The <tt>break</tt> keyword
TKBreak :: Token i

-- | The <tt>continue</tt> keyword
TKContinue :: Token i

-- | The <tt>enum</tt> keyword
TKEnum :: Token i

-- | The <tt>sizeof</tt> keyword
TKSizeof :: Token i

-- | The <tt>_Alignof</tt> keyword
TKAlignof :: Token i

-- | The <tt>struct</tt> keyword
TKStruct :: Token i

-- | THe <tt>goto</tt> keyword
TKGoto :: Token i

-- | Types
TKType :: StorageClass i -> Token i

-- | The <tt>typedef</tt> keyword
TKTypedef :: Token i

-- | The string literal
TKString :: ByteString -> Token i

-- | The C macro
TKMacro :: Macros -> Text -> Token i

-- | The empty token (This is not used by <a>tokenize</a>, but when errors
--   are detected during parsing, the token at error locations cannot be
--   specified)
TKEmpty :: Token i

-- | <a>length</a> returns the token length
length :: Show i => Token i -> Int

-- | <a>emptyToken</a> is used when it cannot be referenced
emptyToken :: Num i => TokenLC i

-- | Utility for <a>TKNum</a>. When the argument is <a>TKNum</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKNum :: Token i -> Bool

-- | Utility for <a>TKType</a>. When the argument is <a>TKType</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKType :: Token i -> Bool

-- | Utility for <a>TKStruct</a>. When the argument is <a>TKStruct</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKStruct :: Token i -> Bool

-- | Utility for <a>TKEnum</a>. When the argument is <a>TKEnum</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKEnum :: Token i -> Bool

-- | Utility for <a>TKIdent</a>. When the argument is <a>TKIdent</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKIdent :: Token i -> Bool

-- | Utility for <a>TKReserved</a>. When the argument is <a>TKReserved</a>,
--   it returns <a>True</a>, otherwise <a>False</a>.
isTKReserved :: Token i -> Bool

-- | Utility for <a>TKMacro</a>. When the argument is <a>TKMacro</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKMacro :: Token i -> Bool

-- | Utility for <a>TKString</a>. When the argument is <a>TKString</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKString :: Token i -> Bool

-- | <a>spanStrLiteral</a> separate the string literal part and the
--   non-string literal part from the input text
spanStrLiteral :: Text -> Maybe (Text, Text)

-- | <a>spanCharLiteral</a> separate the string literal part and the
--   non-string literal part from the input text
spanCharLiteral :: Text -> Maybe (Text, Text)

-- | Take the integer literal from given text.
spanIntLit :: (Eq i, Num i, Read i) => Text -> Maybe (Natural, Token i, Text)

-- | Lookup keyword from <a>Text</a>. If the specified <a>Text</a> is not
--   keyword as C language, <a>lookupKeyword</a> returns <a>Nothing</a>.
lookupKeyword :: forall i. Show i => Text -> Maybe (Token i)

-- | <a>altEmptyToken</a> returns <a>emptyToken</a> if the first token is
--   empty. Otherwise, returns the first token in the token sequence.
altEmptyToken :: Num i => [TokenLC i] -> TokenLC i
instance GHC.Generics.Generic1 Htcc.Tokenizer.Token.TokenLCNums
instance GHC.Generics.Generic (Htcc.Tokenizer.Token.TokenLCNums i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Tokenizer.Token.TokenLCNums i)
instance GHC.Generics.Generic (Htcc.Tokenizer.Token.Token i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Tokenizer.Token.Token i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Tokenizer.Token.TokenLCNums i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Tokenizer.Token.TokenLCNums i)
instance Control.DeepSeq.NFData1 Htcc.Tokenizer.Token.TokenLCNums
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Tokenizer.Token.Token i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Tokenizer.Token.Token i)
instance GHC.Read.Read i => GHC.Read.Read (Htcc.Tokenizer.Token.Token i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.ManagedScope

-- | Type classes common to concepts managed in scope
class ManagedScope a

-- | <a>lookup</a> searches for something managed by the scope by the
--   specified <a>Text</a> from <tt>a</tt>.
lookup :: ManagedScope a => Text -> Map Text a -> Maybe a

-- | Organize <tt>a</tt> list state after scoping.
fallBack :: ManagedScope a => Map Text a -> Map Text a -> Map Text a

-- | Helper function representing an empty something managed by the scope
initial :: ManagedScope a => Map Text a

-- | The type to be used if an error occurs during AST construction.
type ASTError i = (Text, TokenLC i)


-- | General-purpose utilities
module Htcc.Utils.CompilationState

-- | The state type handled during compilation. It has informations
--   required during the compilation process and input data consumed.
type CompilationState cd inp i r = StateT (cd, inp) (Either (ASTError i)) r

-- | <a>itemP</a> peeks at one item from input data
itemP :: MonoFoldable mono => CompilationState cd mono i (Maybe (Element mono))

-- | <a>itemsP</a> peeks at items from input data
itemsP :: (MonoFoldable mono, IsSequence mono) => Index mono -> CompilationState cd mono i (Maybe mono)

-- | <a>itemC</a> consumes at one item from input data. Defines information
--   updates by providing a function that accepts the current information
--   and one item to be consumed and returns the information
itemC :: IsSequence mono => (cd -> Element mono -> cd) -> CompilationState cd mono i (Maybe (Element mono))

-- | <a>itemsC</a> consumes at items from input data. Defines information
--   updates by providing a function that accepts the current information
--   and one item to be consumed and returns the information
itemsC :: IsSequence mono => (cd -> Element mono -> cd) -> Int -> CompilationState cd mono i (Maybe mono)

-- | <a>curCD</a> gets current information
curCD :: CompilationState cd mono i cd

-- | <a>itemCWhen</a> consumes an item when the unary function satisfies
--   the given condition. Defines information updates by providing a
--   function that accepts the current information and one item to be
--   consumed and returns the information
itemCWhen :: (MonoFoldable mono, IsSequence mono) => (cd -> Element mono -> cd) -> (Element mono -> Bool) -> CompilationState cd mono i (Maybe (Element mono))

-- | <a>itemsCWhen</a> consumes items when the unary function satisfies the
--   given condition. Defines information updates by providing a function
--   that accepts the current information and one item to be consumed and
--   returns the information
itemsCWhen :: (MonoFoldable mono, IsSequence mono) => (cd -> Element mono -> cd) -> (Element mono -> Bool) -> CompilationState cd mono i mono

-- | <a>isSatisfied</a> returns <a>True</a> if the input data satisfies the
--   condition of given unary function, otherwise returns <a>False</a>.
isSatisfied :: (mono -> Bool) -> CompilationState cd mono i Bool


-- | The utilities of parsing
module Htcc.Parser.Utils.Core

-- | "expected" error message
expectedMessage :: Show i => Text -> TokenLC i -> [TokenLC i] -> ASTError i

-- | Extract the partial token enclosed in parentheses from the token
--   sequence. If it is invalid, <a>takeBrace</a> returns <tt>(i,
--   Text)</tt> indicating the error location. Otherwise, <a>takeBrace</a>
--   returns a partial token enclosed in parentheses and subsequent tokens.
takeBrace :: forall i. (Integral i, Read i, Show i) => Text -> Text -> [TokenLC i] -> Maybe (Either (TokenLC i) ([TokenLC i], [TokenLC i]))

-- | Get arguments from list of <a>Token</a> (e.g: Given the token of
--   <tt>f(f(g(a, b)), 42);</tt>, return expressions that are the token of
--   "f(g(a, b))" and the token of "42".
takeExps :: Eq i => [TokenLC i] -> Maybe [[TokenLC i]]


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.Utils


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.Var

-- | The type class of the type representing the variable
class Var a

-- | <a>vtype</a> returns the type of the variable
vtype :: Var a => a i -> StorageClass i

-- | The type of variables
type SomeVars v = Map Text v

-- | The informations type about initial value of the global variable
data GVarInitWith i
GVarInitWithZero :: GVarInitWith i
GVarInitWithOG :: Text -> GVarInitWith i
GVarInitWithVal :: i -> GVarInitWith i

-- | The data type of the global variable
data GVar i

-- | The constructor of the global variable
GVar :: StorageClass i -> GVarInitWith i -> GVar i

-- | The type of the global variable
[gvtype] :: GVar i -> StorageClass i

-- | The informations about initial value of the global variable
[initWith] :: GVar i -> GVarInitWith i

-- | The data type of local variable
data LVar a

-- | The constructor of local variable
LVar :: StorageClass a -> !a -> !Natural -> LVar a

-- | The type of the local variable
[lvtype] :: LVar a -> StorageClass a

-- | The offset value from RBP
[rbpOffset] :: LVar a -> !a

-- | The nest depth of a local variable
[nestDepth] :: LVar a -> !Natural

-- | The literal
data Literal a

-- | The literal constructor
Literal :: StorageClass a -> !Natural -> ByteString -> Literal a

-- | The single literal type
[litype] :: Literal a -> StorageClass a

-- | The number of labels placed in the <tt>.data</tt> section
[ln] :: Literal a -> !Natural

-- | The content
[lcts] :: Literal a -> ByteString

-- | The type of global variables
type GlobalVars a = SomeVars (GVar a)

-- | The type of global variables
type LocalVars a = SomeVars (LVar a)

-- | The type of literals
type Literals a = [Literal a]

-- | The data type of local variables
data Vars a

-- | The constructor of variables
Vars :: GlobalVars a -> LocalVars a -> Literals a -> Vars a

-- | The global variables
[globals] :: Vars a -> GlobalVars a

-- | The local variables
[locals] :: Vars a -> LocalVars a

-- | Literals
[literals] :: Vars a -> Literals a

-- | Search for a local variable with a given name
lookupLVar :: Text -> Vars a -> Maybe (LVar a)

-- | Search for a global variable with a given name
lookupGVar :: Text -> Vars a -> Maybe (GVar a)

-- | First, search for local variables, and if not found, search for global
--   variables. If nothing is found, Nothing is returned
lookupVar :: Text -> Vars a -> Maybe (Either (GVar a) (LVar a))

-- | If the specified token is <a>TKIdent</a> and the local variable does
--   not exist in the list, <a>addLVar</a> adds a new local variable to the
--   list, constructs a pair with the node representing the variable, wraps
--   it in <a>Right</a> and return it. Otherwise, returns an error message
--   and token pair wrapped in <a>Left</a>.
addLVar :: (Integral i, Bits i) => Natural -> StorageClass i -> TokenLC i -> Vars i -> Either (ASTError i) (ATree i, Vars i)

-- | If the specified token is <a>TKIdent</a> and the global variable does
--   not exist in the list, <a>addLVar</a> adds a new global variable to
--   the list, constructs a pair with the node representing the variable,
--   wraps it in <a>Right</a> and return it. Otherwise, returns an error
--   message and token pair wrapped in <a>Left</a>.
addGVarWith :: Num i => StorageClass i -> TokenLC i -> GVarInitWith i -> Vars i -> Either (ASTError i) (ATree i, Vars i)

-- | If the specified token is <a>TKIdent</a> and the global variable does
--   not exist in the list, <a>addLVar</a> adds a new global variable that
--   will be initialized by zero to the list, constructs a pair with the
--   node representing the variable, wraps it in <a>Right</a> and return
--   it. Otherwise, returns an error message and token pair wrapped in
--   <a>Left</a>.
addGVar :: Num i => StorageClass i -> TokenLC i -> Vars i -> Either (ASTError i) (ATree i, Vars i)

-- | If the specified token is <a>TKString</a>, <a>addLiteral</a> adds a
--   new literal to the list, constructs a pair with the node representing
--   the variable, wraps it in <a>Right</a> and return it. Otherwise,
--   returns an error message and token pair wrapped in <a>Left</a>.
addLiteral :: (Ord i, Num i) => StorageClass i -> TokenLC i -> Vars i -> Either (ASTError i) (ATree i, Vars i)

-- | Helper function representing an empty variables
initVars :: Vars a

-- | <a>resetLocal</a> initialize the local variable list for <a>Vars</a>
resetLocal :: Vars a -> Vars a

-- | Organize variable list state after scoping
fallBack :: Vars a -> Vars a -> Vars a
instance GHC.Generics.Generic1 Htcc.Parser.ConstructionData.Scope.Var.Vars
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Var.Vars a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Var.Vars a)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Var.Literal a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Var.Literal a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Var.Literal a)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Var.GVarInitWith i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Var.GVarInitWith i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Var.GVarInitWith i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Var.GVarInitWith i)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Var.Vars a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Var.Literal a)
instance Htcc.Parser.ConstructionData.Scope.Var.Var Htcc.Parser.ConstructionData.Scope.Var.Literal
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance Htcc.Parser.AST.Core.Treealizable Htcc.Parser.ConstructionData.Scope.Var.LVar
instance Htcc.Parser.ConstructionData.Scope.Var.Var Htcc.Parser.ConstructionData.Scope.Var.LVar
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Var.LVar a)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance Htcc.Parser.ConstructionData.Scope.Var.Var Htcc.Parser.ConstructionData.Scope.Var.GVar
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Var.GVar i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Var.GVarInitWith i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.Typedef

-- | The data type of a typedef tag
data Typedef a

-- | The contypedefor of a typedef tag
Typedef :: StorageClass a -> !Natural -> Typedef a

-- | The type of this typedef
[tdtype] :: Typedef a -> StorageClass a

-- | The nest depth of this typedef
[tdNestDepth] :: Typedef a -> !Natural

-- | The typedefs data type
type Typedefs a = Map Text (Typedef a)

-- | Given the current nesting number, type, identifier token, and
--   <a>Typedefs</a>, if the specified identifier already exists in the
--   same scope, return an error message and its location as a pair.
--   Otherwise, add a new tag to <a>Typedefs</a> and return it. If the
--   token does not indicate an identifier, an error indicating internal
--   compiler error is returned.
add :: (Num i, Eq i) => Natural -> StorageClass i -> TokenLC i -> Typedefs i -> Either (ASTError i) (Typedefs i)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef a)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef i)
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Typedef.Typedef i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.Tag

-- | The data type of a tag
data Tag i

-- | The constructor of a tag
Tag :: StorageClass i -> !Natural -> Tag i

-- | The type of this tag
[sttype] :: Tag i -> StorageClass i

-- | The nest depth of this tag
[stNestDepth] :: Tag i -> !Natural

-- | The <a>Tags</a> data type
type Tags i = Map Text (Tag i)

-- | Given the current nesting number, type, identifier token, and
--   <a>Tags</a>, if the specified identifier already exists in the same
--   scope, return an error message and its location as a pair. Otherwise,
--   add a new tag to <a>Tags</a> and return it. If the token does not
--   indicate an identifier, an error indicating internal compiler error is
--   returned.
add :: Num i => Natural -> StorageClass i -> TokenLC i -> Tags i -> Either (ASTError i) (Tags i)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Tag.Tag i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.Function

-- | The data type of a typedef tag
data Function a

-- | The contypedefor of a typedef tag
Function :: StorageClass a -> Bool -> Function a

-- | The type of this typedef
[fntype] :: Function a -> StorageClass a

-- | If the function is defined, it will be <a>True</a>, otherwise will be
--   <a>False</a>.
[fnDefined] :: Function a -> Bool

-- | The typedefs data typedefs
type Functions i = Map Text (Function i)

-- | Given the flag (when that is added function, it is <a>True</a>.
--   otherwise <a>False</a>), type, identifier token, and <a>Functions</a>,
--   if the specified identifier already exists in the same scope, return
--   an error message and its location as a pair. Otherwise, add a new tag
--   to <a>Functions</a> and return it. If the token does not indicate an
--   identifier, an error indicating internal compiler error is returned.
add :: Num i => Bool -> StorageClass i -> TokenLC i -> Functions i -> Either (ASTError i) (Functions i)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Function.Function a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Function.Function a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Function.Function a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Function.Function a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Function.Function a)
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Function.Function i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope.Enumerator

-- | The data type of a enumerator
data Enumerator i
Enumerator :: i -> StorageClass i -> Enumerator i

-- | The value of enumerator
[enVal] :: Enumerator i -> i

-- | The underlying type of this enumerator
[enUnderlying] :: Enumerator i -> StorageClass i

-- | The typedefs data typedefs
type Enumerators i = Map Text (Enumerator i)

-- | Given the flag (when that is added function, it is <a>True</a>.
--   otherwise <a>False</a>), type, identifier token, and
--   <a>Enumerators</a>, if the specified identifier already exists in the
--   same scope, return an error message and its location as a pair.
--   Otherwise, add a new tag to <a>Enumerators</a> and return it. If the
--   token does not indicate an identifier, an error indicating internal
--   compiler error is returned.
add :: Num i => StorageClass i -> TokenLC i -> i -> Enumerators i -> Either (ASTError i) (Enumerators i)
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)
instance Htcc.Parser.AST.Core.Treealizable Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator
instance Htcc.Parser.ConstructionData.Scope.ManagedScope.ManagedScope (Htcc.Parser.ConstructionData.Scope.Enumerator.Enumerator i)


-- | The Data type of variables and its utilities used in parsing
module Htcc.Parser.ConstructionData.Scope

-- | The data type of a struct tag
data Scoped i

-- | The constructor of a struct tag
Scoped :: !Natural -> Vars i -> Tags i -> Typedefs i -> Functions i -> Enumerators i -> Scoped i

-- | The nest depth of the parsing process
[curNestDepth] :: Scoped i -> !Natural

-- | scoped all identifiers of variables (local variables, global variables
--   and literals) visible during processing
[vars] :: Scoped i -> Vars i

-- | scoped all struct tags
[structs] :: Scoped i -> Tags i

-- | scoped all typedefs
[typedefs] :: Scoped i -> Typedefs i

-- | scoped all identifires of functions
[functions] :: Scoped i -> Functions i

-- | scoped all identifiers of enumerators
[enumerators] :: Scoped i -> Enumerators i

-- | A type that represents the result of a variable search
data LookupVarResult i

-- | A type constructor indicating that a global variable has been found
FoundGVar :: GVar i -> LookupVarResult i

-- | A type constructor indicating that a local variable has been found
FoundLVar :: LVar i -> LookupVarResult i

-- | A type constructor indicating that a enumerator has been found
FoundEnum :: Enumerator i -> LookupVarResult i

-- | A type constructor indicating that it was not found
NotFound :: LookupVarResult i

-- | <a>addLVar</a> has a scoped type argument and is the same function as
--   <a>addLVar</a> internally.
addLVar :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (ATree i, Scoped i)

-- | <a>addGVar</a> has a scoped type argument and is the same function as
--   <a>addGVar</a> internally.
addGVar :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (ATree i, Scoped i)

-- | <a>addGVarWith</a> has a scoped type argument and is the same function
--   as <a>addLiteral</a> internally.
addGVarWith :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> GVarInitWith i -> Scoped i -> Either (ASTError i) (ATree i, Scoped i)

-- | <a>addLiteral</a> has a scoped type argument and is the same function
--   as <a>addLiteral</a> internally.
addLiteral :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (ATree i, Scoped i)

-- | <a>addTag</a> has a scoped type argument and is the same function as
--   <a>add</a> internally.
addTag :: Num i => StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (Scoped i)

-- | <a>addTypedef</a> has a scoped type argument and is the same function
--   as <a>add</a> internally.
addTypedef :: (Eq i, Num i) => StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (Scoped i)

-- | <a>addFunction</a> has a scoped type argument and is the same function
--   as <a>add</a> internally.
addFunction :: Num i => Bool -> StorageClass i -> TokenLC i -> Scoped i -> Either (ASTError i) (Scoped i)

-- | <a>addEnumerator</a> has a scoped type argument and is the same
--   function as <a>add</a> internally.
addEnumerator :: Num i => StorageClass i -> TokenLC i -> i -> Scoped i -> Either (ASTError i) (Scoped i)

-- | <a>succNest</a> has a scoped type argument and is the same function as
--   <a>succNest</a> internally.
succNest :: Scoped i -> Scoped i

-- | <a>fallBack</a> has a scoped type argument and is the same function as
--   <a>fallBack</a> internally.
fallBack :: Scoped i -> Scoped i -> Scoped i

-- | <a>lookupLVar</a> has a scoped type argument and is the same function
--   as <a>lookupLVar</a> internally.
lookupLVar :: Text -> Scoped i -> Maybe (LVar i)

-- | <a>lookupGVar</a> has a scoped type argument and is the same function
--   as <a>lookupGVar</a> internally.
lookupGVar :: Text -> Scoped i -> Maybe (GVar i)

-- | <a>lookupVar</a> has a scoped type argument and is the same function
--   as <a>lookupVar</a> internally.
lookupVar :: Text -> Scoped i -> LookupVarResult i

-- | <a>lookupTag</a> has a scoped type argument and is the same function
--   as <a>lookupTag</a> internally.
lookupTag :: Text -> Scoped i -> Maybe (Tag i)

-- | <a>lookupTypedef</a> has a scoped type argument and is the same
--   function as <a>lookupTypedef</a> internally.
lookupTypedef :: Text -> Scoped i -> Maybe (Typedef i)

-- | <a>lookupFunction</a> has a scoped type argument and is the same
--   function as <a>lookupFunction</a> internally.
lookupFunction :: Text -> Scoped i -> Maybe (Function i)

-- | <a>lookupEnumerator</a> has a scoped type argument and is the same
--   function as <a>lookupFunction</a> internally.
lookupEnumerator :: Text -> Scoped i -> Maybe (Enumerator i)

-- | Helper function representing an empty scoped data
initScope :: Scoped i

-- | <a>resetLocal</a> has a scoped type argument and is the same function
--   as <a>resetLocal</a> internally.
resetLocal :: Scoped i -> Scoped i
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Parser.ConstructionData.Scope.LookupVarResult i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.LookupVarResult i)
instance GHC.Generics.Generic1 Htcc.Parser.ConstructionData.Scope.Scoped
instance GHC.Generics.Generic (Htcc.Parser.ConstructionData.Scope.Scoped i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Scope.Scoped i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Htcc.Parser.ConstructionData.Scope.Scoped i)


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.ConstructionData.Core

-- | <a>ConstructionData</a> is a set of "things" used during the
--   construction of the AST. Contains error messages and scope
--   information.
data ConstructionData i

-- | The constructor of ConstructionData
ConstructionData :: Warnings i -> Scoped i -> Bool -> ConstructionData i

-- | The warning messages
[warns] :: ConstructionData i -> Warnings i

-- | Scope type
[scope] :: ConstructionData i -> Scoped i

-- | When the statement is <tt>switch</tt>, this flag will be <a>True</a>,
--   otherwise will be <a>False</a>.
[isSwitchStmt] :: ConstructionData i -> Bool

-- | The warning messages type
type Warnings i = Seq (Text, TokenLC i)

-- | Shortcut to function <a>addLVar</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; second (\x -&gt; y { scope = x }) &lt;$&gt; Htcc.Parser.AST.Scope.addLVar ty tkn (scope x)
--   </pre>
addLVar :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ATree i, ConstructionData i)

-- | Shortcut to function <a>addGVar</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; second (\x -&gt; y { scope = x }) &lt;$&gt; Htcc.Parser.AST.Scope.addGVar ty tkn (scope x)
--   </pre>
addGVar :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ATree i, ConstructionData i)

-- | Shortcut to function <a>addGVarWith</a> for variable <tt>x</tt> of tye
--   <a>ConstructionData</a>.
addGVarWith :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> GVarInitWith i -> ConstructionData i -> Either (ASTError i) (ATree i, ConstructionData i)

-- | Shortcut to function <a>addLiteral</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; second (\x -&gt; y { scope = x }) &lt;$&gt; Htcc.Parser.AST.Scope.addLiteral ty tkn (scope x)
--   </pre>
addLiteral :: (Integral i, Bits i) => StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ATree i, ConstructionData i)

-- | Shortcut to function <a>addTag</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; (\y -&gt; x { scope = y }) &lt;$&gt; Htcc.Parser.AST.Scope.addTag ty tkn (scope x)
--   </pre>
addTag :: Num i => StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ConstructionData i)

-- | Shortcut to function <a>addTypedef</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; (\y -&gt; x { scope = y }) &lt;$&gt; Htcc.Parser.AST.Scope.addTypedef ty tkn (scope x)
--   </pre>
addTypedef :: (Eq i, Num i) => StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ConstructionData i)

-- | Shortcut to function <a>addFunction</a> for variable <tt>x</tt> of
--   type <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; (\y -&gt; x { scope = y }) &lt;$&gt; Htcc.Parser.AST.Scope.addFunction ty tkn (scope x)
--   </pre>
addFunction :: Num i => Bool -> StorageClass i -> TokenLC i -> ConstructionData i -> Either (ASTError i) (ConstructionData i)

-- | Shortcut to function <a>addEnumerator</a> for variable <tt>x</tt> of
--   type <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; (\y -&gt; x { scope = y }) &lt;$&gt; Htcc.Parser.AST.Scope.addEnumerator ty tkn (scope x)
--   </pre>
addEnumerator :: Num i => StorageClass i -> TokenLC i -> i -> ConstructionData i -> Either (ASTError i) (ConstructionData i)

-- | Shortcut to function <a>lookupLVar</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupLVar s $ scope x
--   </pre>
lookupLVar :: Text -> ConstructionData i -> Maybe (LVar i)

-- | Shortcut to function <a>lookupGVar</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupGVar s $ scope x
--   </pre>
lookupGVar :: Text -> ConstructionData i -> Maybe (GVar i)

-- | Shortcut to function <a>lookupVar</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupVar s $ scope x
--   </pre>
lookupVar :: Text -> ConstructionData i -> LookupVarResult i

-- | Shortcut to function <a>lookupTag</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupTag s $ scope x
--   </pre>
lookupTag :: Text -> ConstructionData i -> Maybe (Tag i)

-- | Shortcut to function <a>lookupTypedef</a> for variable <tt>x</tt> of
--   type <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupTypedef s $ scope x
--   </pre>
lookupTypedef :: Text -> ConstructionData i -> Maybe (Typedef i)

-- | Shortcut to function <a>lookupFunction</a> for variable <tt>x</tt> of
--   type <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupFunction s $ scope x
--   </pre>
lookupFunction :: Text -> ConstructionData i -> Maybe (Function i)

-- | Shortcut to function <a>lookupEnumerator</a> for variable <tt>x</tt>
--   of type <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; Htcc.Parser.AST.Scope.lookupEnumerator s $ scope x
--   </pre>
lookupEnumerator :: Text -> ConstructionData i -> Maybe (Enumerator i)

-- | Shortcut to function <a>succNest</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; x { scope = Htcc.Parser.AST.Scope.succNest (scope x) }
--   </pre>
succNest :: ConstructionData i -> ConstructionData i

-- | Shortcut to function <a>fallBack</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; post { scope = Htcc.Parser.AST.Scope.fallBack (scope pre) (scope post) }
--   </pre>
fallBack :: ConstructionData i -> ConstructionData i -> ConstructionData i

-- | Shortcut to the initial state of <a>ConstructionData</a>.
initConstructionData :: ConstructionData i

-- | Shortcut to function <a>resetLocal</a> for variable <tt>x</tt> of type
--   <a>ConstructionData</a>. This function is equivalent to
--   
--   <pre>
--   &gt;&gt;&gt; x { scope = Htcc.Parser.AST.Scope.resetLocal (scope x) }
--   </pre>
resetLocal :: ConstructionData i -> ConstructionData i

-- | Function to add warning text.
pushWarn :: Text -> TokenLC i -> ConstructionData i -> ConstructionData i

-- | Returns <a>Nothing</a> if incomplete, otherwise <a>StorageClass</a>.
incomplete :: StorageClass i -> ConstructionData i -> Maybe (StorageClass i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Parser.ConstructionData.Core.ConstructionData i)


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.ConstructionData


-- | The preprocessor
module Htcc.CRules.Preprocessor.Core

-- | The function that executes a proprocess. <b>NOTE</b>: This is not yet
--   implemented.
preprocess :: [TokenLC i] -> Either (ASTError i) [TokenLC i]


-- | The rules of preprocessor of C language
module Htcc.CRules.Preprocessor


-- | The tokenizer
module Htcc.Tokenizer.Core

-- | The core function of <a>tokenize</a>
tokenize' :: (Enum i, Num i, Eq i, Read i, Show i) => Text -> Either (ASTError i) [TokenLC i]


-- | The tokenizer
module Htcc.Tokenizer

-- | Tokenize the <a>Text</a>. If an invalid chraracter matches as C
--   language, the part and the character are returned. Otherwise,
--   <tt>[TokenIdx i]</tt> is returned.
tokenize :: (Integral i, Read i, Show i) => Text -> Either (ASTError i) [TokenLC i]


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.AST.Type

-- | The type to be used when the AST construction is successful
type ASTSuccess i = ([TokenLC i], ATree i, ConstructionData i)

-- | Types used during AST construction
type ASTConstruction i = Either (ASTError i) (ASTSuccess i)

-- | The type of AST list
type ASTs i = [ATree i]

-- | A type that represents the result after AST construction. Quadraple of
--   warning list, constructed abstract syntax tree list, global variable
--   map, literal list.
type ASTResult i = Either (ASTError i) (Warnings i, ASTs i, GlobalVars i, Literals i)

-- | The type synonym of ASTState
type ASTState i r = CompilationState (ConstructionData i) [TokenLC i] i r


-- | The C languge parser and AST constructor
module Htcc.Parser.AST.Var.Init

-- | needs parameters for Assign
type Assign i = [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | Check for valid substitutions
validAssign :: Eq i => TokenLC i -> ATree i -> Either (ASTError i) (ATree i)

-- | Initializing local variables
varInit :: (Read i, Show i, Integral i, Bits i) => Assign i -> StorageClass i -> TokenLC i -> [TokenLC i] -> ConstructionData i -> ASTConstruction i


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.AST.Var


-- | Data types and type synonyms used during AST construction
module Htcc.Parser.AST


-- | The module of the Type parsing
module Htcc.Parser.Parsing.Type

-- | The <a>Just</a> represents an error during construction of the syntax
--   tree, and the <a>Nothing</a> represents no valid constant expression.
type ConstantResult i = Maybe (ASTError i)

-- | <a>constantExp</a> evaluates to a constant expression from token list.
constantExp :: forall i. (Bits i, Integral i, Show i, Read i) => [TokenLC i] -> ConstructionData i -> Either (ConstantResult i) ([TokenLC i], i)

-- | <a>isTypeName</a> returns <tt>True</tt> if the token is a type name,
--   <tt>False</tt> otherwise.
isTypeName :: TokenLC i -> ConstructionData i -> Bool

-- | &lt;math&gt;
takeStructFields :: (Integral i, Show i, Read i, Bits i) => [TokenLC i] -> ConstructionData i -> Either (ASTError i) (Map Text (StructMember i), ConstructionData i)

-- | &lt;math&gt;
takeEnumFiels :: (Integral i, Show i, Read i, Bits i) => StorageClass i -> [TokenLC i] -> ConstructionData i -> Either (ASTError i) (Map Text i, ConstructionData i)

-- | <tt>HT.TKReserved "[", n, HT.TKReserved "]"</tt> from the beginning of
--   the token sequence. <a>arrayDeclSuffix</a> constructs an array type of
--   the given type <tt>t</tt> based on the token sequence if &lt;math&gt;,
--   wraps it in <a>Right</a> and <a>Just</a> and returns it with the rest
--   of the token sequence. If the token <tt>HT.TKReserved "["</tt> exists
--   at the beginning of the token sequence, but the subsequent token
--   sequence is invalid as an array declaration in C programming language,
--   an error mesage and the token at the error location are returned
--   wrapped in <a>Left</a> and <a>Just</a>. When &lt;math&gt;,
--   <a>Nothing</a> is returned.
--   
--   &lt;math&gt;
arrayDeclSuffix :: forall i. (Integral i, Bits i, Show i, Read i) => StorageClass i -> [TokenLC i] -> ConstructionData i -> Maybe (Either (ASTError i) (StorageClass i, [TokenLC i]))

-- | <a>absDeclaration</a> parses abstract type declarations:
--   
--   &lt;math&gt;
absDeclaration :: (Integral i, Bits i, Show i, Read i) => StorageClass i -> [TokenLC i] -> ConstructionData i -> Either (ASTError i) (StorageClass i, [TokenLC i])

-- | &lt;math&gt;
declaration :: (Integral i, Bits i, Show i, Read i) => StorageClass i -> [TokenLC i] -> ConstructionData i -> Either (ASTError i) (StorageClass i, Maybe (TokenLC i), [TokenLC i])

-- | It is obtained by parsing the front part of the type from the token
--   string. e.g. <tt>int (*)[4]</tt> applied to this function yields
--   <tt>int</tt>.
--   
--   &lt;math&gt;
takePreType :: (Integral i, Show i, Read i, Bits i) => [TokenLC i] -> ConstructionData i -> Either (ASTError i) (StorageClass i, [TokenLC i], ConstructionData i)

-- | <a>takeType</a> returns a pair of type (including pointer and array
--   type) and the remaining tokens wrapped in <a>Just</a> only if the
--   token starts with <a>TKType</a>, <a>TKStruct</a> or identifier that is
--   declarated by <tt>typedef</tt>. Otherwise <a>Nothing</a> is returned.
--   
--   &lt;math&gt;
takeType :: (Integral i, Show i, Read i, Bits i) => [TokenLC i] -> ConstructionData i -> Either (ASTError i) (StorageClass i, Maybe (TokenLC i), [TokenLC i], ConstructionData i)

-- | <a>takeTypeName</a> is used to parse type names used for sizeof etc.
--   Version without <a>takeType</a>s identifier.
takeTypeName :: (Integral i, Show i, Read i, Bits i) => [TokenLC i] -> ConstructionData i -> Either (ASTError i) (StorageClass i, [TokenLC i])


-- | Perspective on <tt>typedef</tt> declaration
module Htcc.Parser.Parsing.Typedef

-- | Perform type definition from token string starting from
--   <tt>typedef</tt> token. &lt;math&gt;
typedef :: (Integral i, Show i, Read i, Bits i) => [(TokenLCNums i, Token i)] -> ConstructionData i -> Either (ASTError i) ([TokenLC i], ATree a, ConstructionData i)


-- | The module of the statement expression (GNU extension:
--   <a>https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a>)
module Htcc.Parser.Parsing.StmtExpr

-- | statement expression (GNU extension:
--   <a>https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a>)
--   &lt;math&gt;
stmtExpr :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i


-- | The Global variable declaration
module Htcc.Parser.Parsing.Global.Var

-- | &lt;math&gt;
var :: (Show i, Read i, Integral i, Bits i) => StorageClass i -> Maybe (TokenLC i) -> [TokenLC i] -> ConstructionData i -> ASTConstruction i


-- | The function declaration
module Htcc.Parser.Parsing.Global.Function

-- | &lt;math&gt;
function :: (Show i, Read i, Integral i, Bits i) => StorageClass i -> Maybe (TokenLC i) -> [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i


-- | The module of the globals
module Htcc.Parser.Parsing.Global

-- | <a>globalDef</a> parses global definitions (include functions and
--   global variables) &lt;math&gt;
globalDef :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i


-- | The C languge parser and AST constructor
module Htcc.Parser.Parsing.Core

-- | <a>program</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
program :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ConstructionData i -> Either (ASTError i) (ASTs i, ConstructionData i)

-- | <a>globalDef</a> parses global definitions (include functions and
--   global variables) &lt;math&gt;
globalDef :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>stmt</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
stmt :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>inners</a> is a general function for creating <a>equality</a>,
--   <a>relational</a>, <a>add</a> and <a>term</a> in the following syntax
--   (EBNF) of &lt;math&gt; where &lt;math&gt;.
--   
--   &lt;math&gt;
inners :: ([TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i) -> [(Text, ATKind i)] -> [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>logicalOr</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
logicalOr :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>logicalAnd</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
logicalAnd :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>bitwiseOr</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
bitwiseOr :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>bitwiseXor</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
bitwiseXor :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>bitwiseAnd</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
bitwiseAnd :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>shift</a> indicates (eqref{eq:thirteenth}\) among the comments of
--   <a>inners</a>.
shift :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>add</a> indicates &lt;math&gt; among the comments of <a>inners</a>.
add :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>term</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
term :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>cast</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
cast :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>unary</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
unary :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>factor</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
factor :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>relational</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
relational :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>equality</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>. This is equivalent to the following code:
--   
--   <pre>
--   equality ::  [HT.TokenLC i] -&gt; ATree i -&gt; [LVar i] -&gt; Either (ASTError i) ([HT.TokenLC i], ATree i)
--   equality xs atn scp = (&gt;&gt;=) (relational xs atn scp) $ uncurry3 equality'
--       where
--           equality' ((_, HT.TKReserved "=="):ys) era ars = either Left (uncurry3 id . first3 equality' . second3 (ATNode ATEQ era)) $ relational ys era ars
--           equality' ((_, HT.TKReserved "!="):ys) era ars = either Left (uncurry3 id . first3 equality' . second3 (ATNode ATNEQ era)) $ relational ys era ars
--           equality' ert era ars = Right (ert, era, ars)
--   </pre>
equality :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>conditional</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
conditional :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | <a>assign</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
assign :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | &lt;math&gt;
expr :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ATree i -> ConstructionData i -> ASTConstruction i

-- | Constructs the abstract syntax tree based on the list of token
--   strings. if construction fails, <a>parse</a> returns the error message
--   and the token at the error location. Otherwise, <a>parse</a> returns a
--   list of abstract syntax trees, a set of global variables, and a list
--   of literals.
parse :: (Show i, Read i, Integral i, Bits i) => [TokenLC i] -> ASTResult i

-- | The type of AST list
type ASTs i = [ATree i]

-- | The type to be used when the AST construction is successful
type ASTSuccess i = ([TokenLC i], ATree i, ConstructionData i)

-- | Types used during AST construction
type ASTConstruction i = Either (ASTError i) (ASTSuccess i)

-- | A type that represents the result after AST construction. Quadraple of
--   warning list, constructed abstract syntax tree list, global variable
--   map, literal list.
type ASTResult i = Either (ASTError i) (Warnings i, ASTs i, GlobalVars i, Literals i)

-- | <a>stackSize</a> returns the stack size of variable per function.
stackSize :: (Show i, Integral i) => ATree i -> Natural


-- | The main routines for parsing
module Htcc.Parser.Parsing


-- | Parsing and constructing AST from string
module Htcc.Parser


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Internal

-- | A monad that represents the context of the assembly code
newtype Asm ctx e a
Asm :: (AsmInfo e -> IO a) -> Asm ctx e a

-- | Function that determines the structure of assembly code
[unAsm] :: Asm ctx e a -> AsmInfo e -> IO a

-- | Counter and label information used when generating assembly code
data AsmInfo e
AsmInfo :: Bool -> IORef e -> IORef (Maybe e) -> IORef (Maybe e) -> IORef (Maybe Text) -> AsmInfo e

-- | the flag that indicates whether it is inside the label. If True,
--   indent by single tab,
[inLabel] :: AsmInfo e -> Bool

-- | the label counter
[lblCnt] :: AsmInfo e -> IORef e

-- | the <tt>break</tt> label counter
[brkCnt] :: AsmInfo e -> IORef (Maybe e)

-- | the <tt>continue</tt> label counter
[cntCnt] :: AsmInfo e -> IORef (Maybe e)

-- | the function being processed
[curFn] :: AsmInfo e -> IORef (Maybe Text)

-- | Type representing assembly code
data AsmCodeCtx

-- | the function to switch context
unCtx :: Asm ctx e a -> Asm ctx' e a

-- | the executor that outputs assembly code
runAsm :: (Num e, Enum e) => Asm AsmCodeCtx e a -> IO a

-- | print a string with indentation
putStrWithIndent :: Text -> Asm ctx e ()

-- | print a string with indentation, output is broken on a new line
putStrLnWithIndent :: Text -> Asm ctx e ()

-- | The error context. when this is executed, it will exit the application
--   immediately with <a>exitFailure</a> after printing the message.
errCtx :: Text -> Asm ctx e ()

-- | rewriting functions during processing
writeCurFn :: Maybe Text -> Asm ctx e ()

-- | represents a section of assembly code
section :: Text -> Asm ctx e a -> Asm AsmCodeCtx e a

-- | switch to process in label
labeled :: Asm ctx e a -> Asm ctx e a
instance GHC.Base.Functor (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e)
instance GHC.Base.Applicative (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e)
instance GHC.Base.Monad (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e)
instance Control.Monad.Finally.MonadFinally (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e)
instance GHC.Base.Semigroup (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Htcc.Asm.Intrinsic.Structure.Internal.Asm ctx e a)


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Section.Text.Directive

-- | the type representing the context inside the text section
data TextSectionCtx

-- | the type representing the context inside the label
data TextLabelCtx

-- | the type representing the context inside the instruction that needs to
--   be specified, such as a <tt>jmp</tt> instruction.
data TargetLabelCtx

-- | <tt>text</tt> section
text :: Asm TextSectionCtx e a -> Asm AsmCodeCtx e a

-- | <tt>global</tt> directive
global :: Text -> Asm TextSectionCtx e ()

-- | the label as function definition in text section
fn :: Text -> Asm TextLabelCtx e a -> Asm TextSectionCtx e a

-- | the label in text section
label :: (Show i, Show e) => Text -> i -> Asm TextLabelCtx e ()

-- | begin label
begin :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | end label
end :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | else label
eLse :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | case label
cAse :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | break label
break :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | continue label
continue :: (Show e, Show i) => i -> Asm TextLabelCtx e ()

-- | goto label
gotoLabel :: Text -> Asm TextLabelCtx e ()

-- | reference to general label
ref :: (Show e, Show i) => Text -> i -> Asm TargetLabelCtx e ()

-- | reference to begin label
refBegin :: (Show e, Show i) => i -> Asm TargetLabelCtx e ()

-- | reference to end label
refEnd :: (Show e, Show i) => i -> Asm TargetLabelCtx e ()

-- | reference to else label
refElse :: (Show e, Show i) => i -> Asm TargetLabelCtx e ()

-- | reference for break label
refBreak :: (Show e, Show i) => i -> Asm TargetLabelCtx e ()

-- | reference for break label (applying value by <a>brkCnt</a>)
refHBreak :: Show e => Asm TargetLabelCtx e ()

-- | reference for continue label
refContinue :: (Show e, Show i) => i -> Asm TargetLabelCtx e ()

-- | reference for break label (applying value by <a>cntCnt</a>)
refHContinue :: Show e => Asm TargetLabelCtx e ()

-- | reference for return label
refReturn :: Show e => Asm TargetLabelCtx e ()

-- | reference for goto label
refGoto :: Text -> Asm TargetLabelCtx e ()

-- | generate cases and return abstract tree
makeCases :: (Show e, Enum e, Integral e, Show i, Num i) => [ATree i] -> Asm TextLabelCtx e [ATree i]


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Section.Text.Operations

-- | count up the internal label counter
incrLbl :: Enum e => Asm TextLabelCtx e e

-- | apply value to cntCnt from the current label number
applyCnt :: Asm ctx e ()

-- | apply value to brkCnt from the current label number
applyBrk :: Asm ctx e ()

-- | Apply values from lblCnt to brkCnt and cntCnt in function execution
--   scope, and return values to their original state when exiting the
--   scope
bracketBrkCnt :: Asm TextLabelCtx e () -> Asm TextLabelCtx e ()


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction

-- | Unit of size of data to be loaded
data SizeUnit

-- | 8 bits
Byte :: SizeUnit

-- | 16 bits
Word :: SizeUnit

-- | 32 bits
DWord :: SizeUnit

-- | A class of x86_64 instructions with unary arguments.
class Show a => UnaryInstruction a

-- | <tt>push</tt> instruction
push :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | <tt>pop</tt> instruction
pop :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | <tt>pushl</tt> instruction
pushl :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | <tt>popl</tt> instruction
popl :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | <tt>idiv</tt> instruction
idiv :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | <tt>not</tt> instruction
not :: UnaryInstruction a => a -> Asm TextLabelCtx e ()

-- | A class of x86_64 instructions with binary arguments.
class Show a => BinaryInstruction a

-- | <tt>mov</tt> instruction
mov :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>movl</tt> instruction
movl :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>movsx</tt> instruction
movsx :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>movsxd</tt> instruction
movsxd :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>movabs</tt> instruction
movabs :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>movzb</tt> instruction
movzb :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>cmp</tt> instruction
cmp :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>add</tt> instruction
add :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>sub</tt> instruction
sub :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>imul</tt> instruction
imul :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>and</tt> instruction
and :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>or</tt> instruction
or :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>xor</tt> instruction
xor :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>shl</tt> instruction
shl :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>sar</tt> instruction
sar :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()
lea :: (BinaryInstruction a, BinaryInstruction b) => a -> b -> Asm TextLabelCtx e ()

-- | <tt>offset</tt> instruction
newtype Offset

-- | The constructor of <tt>offset</tt> instruction
Offset :: Text -> Offset

-- | The <tt>ptr</tt> instruction
data Ptr a

-- | The constructor of <tt>ptr</tt> instruction
Ptr :: SizeUnit -> Ref a -> Ptr a

-- | <tt>sete</tt> instruction
sete :: Register -> Asm TextLabelCtx e ()

-- | <tt>setne</tt> instruction
setne :: Register -> Asm TextLabelCtx e ()

-- | <tt>setl</tt> instruction
setl :: Register -> Asm TextLabelCtx e ()

-- | <tt>setle</tt> instruction
setle :: Register -> Asm TextLabelCtx e ()

-- | <tt>setg</tt> instruction
setg :: Register -> Asm TextLabelCtx e ()

-- | <tt>setge</tt> instruction
setge :: Register -> Asm TextLabelCtx e ()

-- | <tt>byte</tt> is a helper function for intuitively writing
--   <tt>byte</tt> instructions
byte :: IsOperand a => (SizeUnit -> Ref a -> Ptr a) -> Ref a -> Ptr a

-- | <tt>word</tt> is a helper function for intuitively writing
--   <tt>word</tt> instructions
word :: IsOperand a => (SizeUnit -> Ref a -> Ptr a) -> Ref a -> Ptr a

-- | <tt>dword</tt> is a helper function for intuitively writing
--   <tt>dword</tt> instructions
dword :: IsOperand a => (SizeUnit -> Ref a -> Ptr a) -> Ref a -> Ptr a

-- | <tt>cqo</tt> instruction
cqo :: Asm TextLabelCtx e ()

-- | <tt>ret</tt> instruction
ret :: Asm TextLabelCtx e ()

-- | <tt>leave</tt> instruction
leave :: Asm TextLabelCtx e ()

-- | <tt>jmp</tt> instruction
jmp :: Asm TargetLabelCtx e () -> Asm TextLabelCtx e ()

-- | <tt>je</tt> instruction
je :: Asm TargetLabelCtx e () -> Asm TextLabelCtx e ()

-- | <tt>jne</tt> instruction
jne :: Asm TargetLabelCtx e () -> Asm TextLabelCtx e ()

-- | <tt>jnz</tt> instruction
jnz :: Asm TargetLabelCtx e () -> Asm TextLabelCtx e ()

-- | <tt>call</tt> instruction
call :: Text -> Asm TextLabelCtx e ()
instance GHC.Enum.Bounded Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.SizeUnit
instance GHC.Enum.Enum Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.SizeUnit
instance GHC.Classes.Ord Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.SizeUnit
instance GHC.Classes.Eq Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.SizeUnit
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction GHC.Integer.Type.Integer
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction GHC.Types.Int
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction GHC.Natural.Natural
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction Htcc.Asm.Intrinsic.Register.Register
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.Offset
instance (Htcc.Asm.Intrinsic.Operand.IsOperand a, Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction a) => Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction (Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.Ptr a)
instance Htcc.Asm.Intrinsic.Operand.IsOperand a => Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.BinaryInstruction (Htcc.Asm.Intrinsic.Operand.Ref a)
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction GHC.Integer.Type.Integer
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction GHC.Types.Int
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction GHC.Natural.Natural
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction Htcc.Asm.Intrinsic.Register.Register
instance Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.Offset
instance Htcc.Asm.Intrinsic.Operand.IsOperand a => Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.UnaryInstruction (Htcc.Asm.Intrinsic.Operand.Ref a)
instance Htcc.Asm.Intrinsic.Operand.IsOperand a => GHC.Show.Show (Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.Ptr a)
instance GHC.Show.Show Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.Offset
instance GHC.Show.Show Htcc.Asm.Intrinsic.Structure.Section.Text.Instruction.SizeUnit


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Section.Text


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure.Section.Data

-- | the type representing the context inside the data section
data DataSectionCtx

-- | the type representing the context inside the data label
data DataLabelCtx

-- | data section
dAta :: Asm DataSectionCtx e a -> Asm AsmCodeCtx e a

-- | label in data section.
label :: Text -> Asm DataLabelCtx e a -> Asm DataSectionCtx e a

-- | <tt>byte</tt> in data section
byte :: ByteString -> Asm DataLabelCtx e ()

-- | <tt>.x.byte</tt> in data section
sbyte :: (Num i, Show i) => Natural -> i -> Asm DataLabelCtx e ()

-- | <tt>ascii</tt> in data section
ascii :: ByteString -> Asm DataLabelCtx e ()

-- | <tt>asciiz</tt> in data section
asciiz :: ByteString -> Asm DataLabelCtx e ()

-- | <tt>zero</tt> in data section
zero :: Natural -> Asm DataLabelCtx e ()

-- | <tt>quad</tt> in data section
quad :: Text -> Asm DataLabelCtx e ()


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Intrinsic.Structure


-- | The modules of intrinsic (x86_64) assembly
module Htcc.Asm.Generate.Core

-- | data section of assembly code
dataSection :: (Show i, Ord i, Num i) => Map Text (GVar i) -> [Literal i] -> Asm AsmCodeCtx e ()

-- | text section of assembly code
textSection :: (Integral e, Show e, IsOperand i, Integral i, Show i, UnaryInstruction i, BinaryInstruction i) => [ATree i] -> Asm AsmCodeCtx e ()


-- | The executable module for compilation
module Htcc.Asm.Generate

-- | input string, C source code
type InputCCode = Text

-- | Executor that receives information about the constructed AST, global
--   variables, and literals and composes assembly code
casm' :: (Integral e, Show e, Integral i, IsOperand i, UnaryInstruction i, BinaryInstruction i) => ASTs i -> GlobalVars i -> Literals i -> Asm AsmCodeCtx e ()

-- | Build AST from string of C source code
buildAST :: (Integral i, Read i, Show i, Bits i) => InputCCode -> ASTResult i

-- | Print warning or error message if building AST from string of C source
--   code has some problems
execAST :: (Integral i, Read i, Show i, Bits i) => Bool -> FilePath -> InputCCode -> IO (Maybe (ASTs i, GlobalVars i, Literals i))
instance GHC.Enum.Bounded Htcc.Asm.Generate.MessageType
instance GHC.Enum.Enum Htcc.Asm.Generate.MessageType
instance GHC.Classes.Ord Htcc.Asm.Generate.MessageType
instance GHC.Classes.Eq Htcc.Asm.Generate.MessageType
instance GHC.Show.Show Htcc.Asm.Generate.MessageType


-- | The executable module for compilation
module Htcc.Asm

-- | Generate full assembly code from string of C source code
casm :: (IsOperand i, UnaryInstruction i, BinaryInstruction i, Integral i) => (ASTs i, GlobalVars i, Literals i) -> IO ()


-- | Build AST from C source code
module Htcc.Visualizer.Core

-- | Build AST from C source code
visualize :: Show i => ASTs i -> SizeSpec V2 Double -> FilePath -> IO ()


-- | Build AST from C source code
module Htcc.Visualizer
