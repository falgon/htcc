-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/falgon/htcc#readme</a>
@package htcc
@version 0.0.0.1


module Htcc.Utils

-- | Standard error output shortcut.
putStrLnErr :: Text -> IO ()

-- | Standard error output and exit shortcut.
err :: Text -> IO ()

-- | Update the first component of triple.
first3 :: (a -> d) -> (a, b, c) -> (d, b, c)

-- | Update the second component of triple.
second3 :: (b -> d) -> (a, b, c) -> (a, d, c)

-- | Update the third component of triple.
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)

-- | The counter is incremented by one each time it is executed.
counter :: Enum a => a -> IO (IO a)

-- | For mappings &lt;math&gt; to an element &lt;math&gt; of a set
--   &lt;math&gt;, &lt;math&gt; where &lt;math&gt; is the boolean domain.
--   This function will stop evaluation when the result of &lt;math&gt; is
--   <a>True</a> (short circuit evaluation). This is equivalent to:
--   
--   <pre>
--   f1 x || f2 x || f3 x == lor [f1, f2, f3] x
--   </pre>
lor :: [a -> Bool] -> a -> Bool

-- | Sum of product form. For mappings &lt;math&gt; to an element
--   &lt;math&gt; of a set &lt;math&gt;, &lt;math&gt; where &lt;math&gt; is
--   the Boolean domain. This function will stop evaluation when the result
--   of &lt;math&gt; is <a>True</a> (short circuit evaluation).
sop :: [a -> Bool] -> [a] -> Bool

-- | The <a>Text</a> version of <a>sop</a>.
sopText :: [Char -> Bool] -> Text -> Bool


module Htcc.CRules.Char

-- | Return <a>True</a> if it is a valid character.
isValidChar :: Char -> Bool

-- | Class of type that can be treated as a set of characters.
class GenericStr a

-- | Returns <a>True</a> if the set of characters is a valid C language
--   characters.
isValid :: GenericStr a => a -> Bool
instance Htcc.CRules.Char.GenericStr GHC.Base.String
instance Htcc.CRules.Char.GenericStr Data.Text.Internal.Text


module Htcc.Token

-- | Utility for <a>TKFor</a>. When the argument is <a>TKFor</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKFor :: Token i -> Bool

-- | Utility for <a>TKIdent</a>. When the argument is <a>TKIdent</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKIdent :: Token i -> Bool

-- | Utility for <a>TKNum</a>. When the argument is <a>TKNum</a>, it
--   returns <a>True</a>, otherwise <a>False</a>.
isTKNum :: Token i -> Bool

-- | Utility for <a>TKReserved</a>. When the argument is <a>TKReserved</a>,
--   it returns <a>True</a>, otherwise <a>False</a>.
isTKReserved :: Token i -> Bool

-- | Specially for token data type
data TokenFor i

-- | The for keyword
TKForkw :: TokenFor i

-- | The initial section of for statement
TKForInit :: [Token i] -> TokenFor i

-- | The conditional section of for statement
TKForCond :: [Token i] -> TokenFor i

-- | The incremental section of for statement
TKForIncr :: [Token i] -> TokenFor i

-- | Token type
data Token i

-- | The reserved token
TKReserved :: String -> Token i

-- | The number data
TKNum :: i -> Token i

-- | The identifier
TKIdent :: String -> Token i

-- | The return keyword
TKReturn :: Token i

-- | The if keyword
TKIf :: Token i

-- | The else keyword
TKElse :: Token i

-- | The while keyword
TKWhile :: Token i

-- | The for keyword
TKFor :: TokenFor i -> Token i

-- | Tokenize from <a>String</a>. If it fails, the Left that wraps the
--   value representing that point is returned.
tokenize :: Read i => String -> Either Int [Token i]
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Token.TokenFor i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Token.TokenFor i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Htcc.Token.Token i)
instance GHC.Show.Show i => GHC.Show.Show (Htcc.Token.Token i)


module Htcc.Parse

-- | The local variable
data LVar a

-- | The constructor of local variable
LVar :: String -> a -> LVar a

-- | The name of local variable
[name] :: LVar a -> String

-- | The offset value
[offset] :: LVar a -> a

-- | Specially for syntax tree type
data ATKindFor a

-- | The for keyword
ATForkw :: ATKindFor a

-- | The initial section of for statement
ATForInit :: ATree a -> ATKindFor a

-- | The conditional section of for statement
ATForCond :: ATree a -> ATKindFor a

-- | The incremental section of for statement
ATForIncr :: ATree a -> ATKindFor a

-- | The statement section of for statement
ATForStmt :: ATree a -> ATKindFor a

-- | The syntax tree type
data ATKind a

-- | &lt;math&gt;
ATAdd :: ATKind a

-- | &lt;math&gt;
ATSub :: ATKind a

-- | &lt;math&gt;
ATMul :: ATKind a

-- | &lt;math&gt;
ATDiv :: ATKind a

-- | modulus
ATMod :: ATKind a

-- | bitwise and
ATAnd :: ATKind a

-- | bitwise or
ATOr :: ATKind a

-- | bitwise xor
ATXor :: ATKind a

-- | bitwise not
ATNot :: ATKind a

-- | left shift &lt;math&gt;
ATShl :: ATKind a

-- | right shift &lt;math&gt;
ATShr :: ATKind a

-- | &lt;math&gt;
ATLT :: ATKind a

-- | &lt;math&gt;
ATLEQ :: ATKind a

-- | &lt;math&gt;
ATGT :: ATKind a

-- | &lt;math&gt;
ATGEQ :: ATKind a

-- | &lt;math&gt;
ATEQ :: ATKind a

-- | &lt;math&gt;
ATNEQ :: ATKind a

-- | The number
ATNum :: a -> ATKind a

-- | The assign operator
ATAssign :: ATKind a

-- | The return keyword
ATReturn :: ATKind a

-- | The if keyword
ATIf :: ATKind a

-- | The else keyword
ATElse :: ATKind a

-- | The while keyword
ATWhile :: ATKind a

-- | The for keyword
ATFor :: [ATKindFor a] -> ATKind a

-- | The block
ATBlock :: [ATree a] -> ATKind a

-- | The local variable. It has a offset value
ATLVar :: a -> ATKind a

-- | The function. It has a offset value and arguments (<a>Maybe</a>).
ATCallFunc :: Text -> Maybe [ATree a] -> ATKind a

-- | The data structure of abstract syntax tree
data ATree a

-- | The empty node
ATEmpty :: ATree a

-- | <a>ATKind</a> representing the kind of node and the two branches
--   <a>ATree</a> it has
ATNode :: ATKind a -> ATree a -> ATree a -> ATree a

-- | An utility of <a>ATForInit</a>. When an argument is <a>ATForInit</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForInit :: ATKindFor a -> Bool

-- | An utility of <a>ATForCond</a>. When an argument is <a>ATForCond</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForCond :: ATKindFor a -> Bool

-- | An utility <a>ATForStmt</a>. When an argument is <a>ATForStmt</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForStmt :: ATKindFor a -> Bool

-- | An utility <a>ATForIncr</a>. When an argument is <a>ATForIncr</a>,
--   return <a>True</a> otherwise <a>False</a>
isATForIncr :: ATKindFor a -> Bool

-- | take ATree data from <a>ATKindFor</a>.
fromATKindFor :: ATKindFor a -> ATree a

-- | <a>inners</a> is a general function for creating <a>equality</a>,
--   <a>relational</a>, <a>add</a> and <a>term</a> in the following syntax
--   (EBNF) of &lt;math&gt; where &lt;math&gt;.
--   
--   &lt;math&gt;
inners :: ([Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])) -> [(String, ATKind i)] -> [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>bitwiseOr</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
bitwiseOr :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>bitwiseXor</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
bitwiseXor :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>bitwiseAnd</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
bitwiseAnd :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>add</a> indicates &lt;math&gt; among the comments of <a>inners</a>.
add :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>term</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
term :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>unary</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
unary :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>factor</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
factor :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>relational</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
relational :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>equality</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>. This is equivalent to the following code:
--   
--   <pre>
--   equality ::  [Token i] -&gt; ATree i -&gt; [LVar i] -&gt; Maybe ([Token i], ATree i)
--   equality xs atn vars = flip (maybe Nothing) (relational xs atn vars) $ uncurry3 equality'
--       where
--           equality' (TKReserved "+":ys) era ars = maybe Nothing (uncurry id . first3 equality' . second3 (ATNode ATEQ era)) $ relational ys era ars
--           equality' (TKReserved "-":ys) era ars = maybe Nothing (uncurry id . first3 equality' . second3 (ATNode ATNEQ era)) $ relational ys era ars
--           equality' ert era ars = Just (ert, era, ars)
--   </pre>
equality :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>assign</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
assign :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>expr</a> is equivalent to <a>equality</a>.
expr :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>stmt</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
stmt :: (Show i, Eq i, Num i) => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>program</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
program :: (Show i, Eq i, Num i) => [Token i] -> [LVar i] -> Maybe [(ATree i, [LVar i])]

-- | Constructs the abstract syntax tree based on the list of token
--   strings. if construction fails, <a>Nothing</a> is returned.
parse :: (Show i, Num i, Eq i) => [Token i] -> Maybe ([ATree i], Int)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parse.ATKindFor a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parse.ATKind a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parse.ATree a)
instance GHC.Show.Show a => GHC.Show.Show (Htcc.Parse.LVar a)


module Htcc.CAsm

-- | Simulate the stack machine by traversing an abstract syntax tree and
--   output assembly codes.
genStmt :: Show i => IO Int -> ATree i -> IO ()

-- | Generate full assembly code from C language program
casm :: String -> IO ()
