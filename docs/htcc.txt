-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/falgon/htcc#readme</a>
@package htcc
@version 0.0.0.1


module C.Token

-- | Token type
data Token i
TKReserved :: Char -> Token i
TKNum :: i -> Token i

-- | Tokenize from <a>String</a>. If it fails, the Left that wraps the
--   value representing that point is returned.
tokenize :: Read i => String -> Either Int [Token i]
instance GHC.Show.Show i => GHC.Show.Show (C.Token.Token i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (C.Token.Token i)


module C.Parse

-- | Syntax tree type
data ATKind a
ATAdd :: ATKind a
ATSub :: ATKind a
ATMul :: ATKind a
ATDiv :: ATKind a
ATNum :: a -> ATKind a

-- | Abstract syntax tree
data ATree a
ATEmpty :: ATree a
ATNode :: ATKind a -> ATree a -> ATree a -> ATree a

-- | <a>inners</a> is a general function for creating expr and factor in
--   the following syntax (EBNF) of LL (1).
--   
--   &lt;math&gt;
inners :: ([Token i] -> ATree i -> Maybe ([Token i], ATree i)) -> [(Char, ATKind i)] -> [Token i] -> ATree i -> Maybe ([Token i], ATree i)

-- | <a>expr</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>. This is equivalent to the following code:
--   
--   <pre>
--   expr ::  [Token i] -&gt; ATree i -&gt; Maybe ([Token i], ATree i)
--   expr xs atn = flip (maybe Nothing) (term xs atn) $ \(ert, erat) -&gt; expr' ert erat
--       where
--           expr' (TKReserved '+':ys) era = maybe Nothing (uncurry id . first expr' . second (ATNode ATAdd era)) $ term ys era
--           expr' (TKReserved '-':ys) era = maybe Nothing (uncurry id . first expr' . second (ATNode ATSub era)) $ term ys era
--           expr' ert era = Just (ert, era)
--   </pre>
expr :: Num i => [Token i] -> ATree i -> Maybe ([Token i], ATree i)

-- | <a>term</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>. Same as <a>expr</a>. This is equivalent to the
--   following code:
--   
--   <pre>
--   term ::  [Token i] -&gt; ATree i -&gt; Maybe ([Token i], ATree i)
--   term xs atn = flip (maybe Nothing) (unary xs atn) $ \(ert, erat) -&gt; term' ert erat
--       where
--           term' (TKReserved '*':ys) era = maybe Nothing (uncurry id . first expr' . second (ATNode ATMul era)) $ unary ys era
--           term' (TKReserved '/':ys) era = maybe Nothing (uncurry id . first expr' . second (ATNode ATDiv era)) $ unary ys era
--           term' ert era = Just (ert, era)
--   </pre>
term :: Num i => [Token i] -> ATree i -> Maybe ([Token i], ATree i)

-- | <a>unary</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
unary :: Num i => [Token i] -> ATree i -> Maybe ([Token i], ATree i)

-- | <a>factor</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
factor :: Num i => [Token i] -> ATree i -> Maybe ([Token i], ATree i)

-- | Constructs the abstract syntax tree based on the list of token
--   strings. if construction fails, <a>Nothing</a> is returned.
parse :: Num i => [Token i] -> Maybe (ATree i)


module C.Generate

-- | Simulate the stack machine by traversing an abstract syntax tree and
--   output assembly codes.
generate :: Show i => ATree i -> IO ()


module C.Utils

-- | Standard error output shortcut
putStrLnErr :: String -> IO ()

-- | Standard error output and exit shortcut
err :: String -> IO ()
