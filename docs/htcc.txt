-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/falgon/htcc#readme</a>
@package htcc
@version 0.0.0.1


module C.Token

-- | Token type
data Token i

-- | The reserved token
TKReserved :: String -> Token i

-- | The number data
TKNum :: i -> Token i

-- | The identifier
TKIdent :: String -> Token i

-- | Tokenize from <a>String</a>. If it fails, the Left that wraps the
--   value representing that point is returned.
tokenize :: Read i => String -> Either Int [Token i]
instance GHC.Show.Show i => GHC.Show.Show (C.Token.Token i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (C.Token.Token i)


module C.Utils

-- | Standard error output shortcut
putStrLnErr :: String -> IO ()

-- | Standard error output and exit shortcut
err :: String -> IO ()
first3 :: (a -> d) -> (a, b, c) -> (d, b, c)
second3 :: (b -> d) -> (a, b, c) -> (a, d, c)


module C.Parse
data LVar a

-- | The local variable
LVar :: String -> a -> LVar a

-- | The name of local variable
[name] :: LVar a -> String

-- | The offset value
[offset] :: LVar a -> a

-- | The syntax tree type
data ATKind a

-- | &lt;math&gt;
ATAdd :: ATKind a

-- | &lt;math&gt;
ATSub :: ATKind a

-- | &lt;math&gt;
ATMul :: ATKind a

-- | &lt;math&gt;
ATDiv :: ATKind a

-- | &lt;math&gt;
ATLT :: ATKind a

-- | &lt;math&gt;
ATLEQ :: ATKind a

-- | &lt;math&gt;
ATGT :: ATKind a

-- | &lt;math&gt;
ATGEQ :: ATKind a

-- | &lt;math&gt;
ATEQ :: ATKind a

-- | &lt;math&gt;
ATNEQ :: ATKind a

-- | The number
ATNum :: a -> ATKind a

-- | The assign operator
ATAssign :: ATKind a

-- | The local variable. It has a offset value
ATLVar :: a -> ATKind a

-- | The data structure of abstract syntax tree
data ATree a

-- | The empty node
ATEmpty :: ATree a

-- | <a>ATKind</a> representing the kind of node and the two branches
--   <a>ATree</a> it has
ATNode :: ATKind a -> ATree a -> ATree a -> ATree a

-- | <a>inners</a> is a general function for creating <a>equality</a>,
--   <a>relational</a>, <a>add</a> and <a>term</a> in the following syntax
--   (EBNF) of LL (1).
--   
--   &lt;math&gt;
inners :: ([Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])) -> [(String, ATKind i)] -> [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>add</a> indicates &lt;math&gt; among the comments of <a>inners</a>.
add :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>term</a> indicates &lt;math&gt; amont the comments of
--   <a>inners</a>.
term :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>unary</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
unary :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>factor</a> indicates &lt;math&gt; amount the comments of
--   <a>inners</a>.
factor :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>relational</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
relational :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>equality</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>. This is equivalent to the following code:
--   
--   <pre>
--   equality ::  [Token i] -&gt; ATree i -&gt; [LVar i] -&gt; Maybe ([Token i], ATree i)
--   equality xs atn vars = flip (maybe Nothing) (relational xs atn vars) $ uncurry3 equality'
--       where
--           equality' (TKReserved "+":ys) era ars = maybe Nothing (uncurry id . first3 equality' . second3 (ATNode ATEQ era)) $ relational ys era ars
--           equality' (TKReserved "-":ys) era ars = maybe Nothing (uncurry id . first3 equality' . second3 (ATNode ATNEQ era)) $ relational ys era ars
--           equality' ert era ars = Just (ert, era, ars)
--   </pre>
equality :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>assign</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
assign :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>expr</a> is equivalent to <a>equality</a>.
expr :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>stmt</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
stmt :: Num i => [Token i] -> ATree i -> [LVar i] -> Maybe ([Token i], ATree i, [LVar i])

-- | <a>program</a> indicates &lt;math&gt; among the comments of
--   <a>inners</a>.
program :: Num i => [Token i] -> [LVar i] -> Maybe [(ATree i, [LVar i])]

-- | Constructs the abstract syntax tree based on the list of token
--   strings. if construction fails, <a>Nothing</a> is returned.
--   <a>parse</a> is equivalent to <a>program</a>.
parse :: Num i => [Token i] -> Maybe ([ATree i], Int)


module C.Generate

-- | Simulate the stack machine by traversing an abstract syntax tree and
--   output assembly codes.
generate :: Show i => ATree i -> IO ()
